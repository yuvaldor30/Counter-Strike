/* Plugin generated by AMXX-Studio */

#include "amxmodx.inc"
#include "npc_api.inc" 
#include "accounts.inc"
#include "oldmenus.inc"
#include "engine.inc"

#define PLUGIN "NPC Creator API"
#define VERSION "1.0"
#define AUTHOR "MJ"

#define NPC_MAX_AMOUNT_OF_NPCS 10
#define NPC_CREATED_NPC_DELAY_USE 2.0
#define NPC_MIN_NPCS_DISTANCE 140.0
#define NPC_MIN_DELETE_DISTANCE 100.0

#define PREFIX "NPC System"

#pragma semicolon 1

enum _: eNpcData
{
	Float:nd_fOrigin[3],
	Float:nd_fAngles[3]
}

enum _: eForwards
{
	FWD_NPCLOADITEMS,
	FWD_NPCTOUCHED,
	FWD_NPCITEMCHOSEN
}

new g_iEntities;

new const Float:g_fMinSize[3] = {-16.0,-16.0,-36.0};
new const Float:g_fMaxSize[3] = {16.0,16.0,36.0};

new const g_szEntityClassname[] = "npc_manager";

new const g_szEntityModel[] = "models/player/vip/vip.mdl";

new const g_szFile[] = "addons/amxmodx/data/npcs_data.txt";
new const g_szTempFile[] = "addons/amxmodx/data/npcs_tempdata.txt";

new Array:g_aNpcIDs = Invalid_Array;

new Trie:g_tNpcs = Invalid_Trie;

new Array:g_aItems = Invalid_Array;


new g_szMap[20];

new g_hForwards[eForwards];

public plugin_init() {
	register_plugin(PLUGIN, VERSION, AUTHOR);
	
	while(g_aNpcIDs == Invalid_Array)
		g_aNpcIDs = ArrayCreate();
		
	while(g_tNpcs == Invalid_Trie)
		g_tNpcs = TrieCreate();
	
	get_mapname(g_szMap,charsmax(g_szMap));
	strtolower(g_szMap);
	
	cmd_LoadFile();
	
	register_clcmd("say /npc","menu_NPC");
	
	register_touch(g_szEntityClassname,"player","menu_TouchNPC");
	
	g_hForwards[FWD_NPCLOADITEMS] = CreateMultiForward("fwd_NpcLoadItems",ET_IGNORE);
	g_hForwards[FWD_NPCTOUCHED] = CreateMultiForward("fwd_NpcTocuhed",ET_IGNORE,FP_CELL,FP_CELL);
	g_hForwards[FWD_NPCITEMCHOSEN] = CreateMultiForward("fwd_NpcItemChosen",ET_IGNORE,FP_CELL,FP_CELL);
	
	set_task(0.1,"cmd_LoadItems");
}

public cmd_LoadItems()
{	
	while(g_aItems == Invalid_Array)
		g_aItems = ArrayCreate(eItemData);
		
	new iReturn;
	
	ExecuteForward(g_hForwards[FWD_NPCLOADITEMS],iReturn);
}

public plugin_natives()
{
	register_native("npc_AddItem","native_AddItem");
}

public native_AddItem(const iPluginID, const iParams)
{
	new iRequiredParams = 1;
	
	if(iParams < iRequiredParams)
	{
		log_error(AMX_ERR_NATIVE,"[%s] cannot find enough parameters. %i/%i",PLUGIN ,iParams, iRequiredParams);
		return PLUGIN_CONTINUE;
	}
	
	new aData[eItemData];
	
	get_array(1,aData,sizeof aData);
		
	ArrayPushArray(g_aItems,aData,sizeof aData);
	
	return aData[id_iID];
}

public plugin_precache()
{
	precache_model(g_szEntityModel);
}

public plugin_end()
{	
	ArrayDestroy(g_aNpcIDs);
	TrieDestroy(g_tNpcs);
}

public menu_NPC(const iIndex)
{
	if(get_user_access(iIndex) < GameMaster)
	{
		client_print_color(iIndex,print_team_default,"^4[%s] ^1You have no access to this command.",PREFIX);
		
		return PLUGIN_HANDLED;
	}
	
	new szText[512],iLen,iKeys;
	
	iLen += formatex(szText[iLen],charsmax(szText) - iLen,"\r[ \w%s \r] \wNPC Manager Menu^nTotal NPCs: \y%d^n\dChoose your favorite option:^n^n",PREFIX,g_iEntities);
	
	iLen += formatex(szText[iLen],charsmax(szText) - iLen,"\%c1. \wCreate a \yNPC^n",g_iEntities < NPC_MAX_AMOUNT_OF_NPCS ? 'r' : 'd');
	
	iLen += formatex(szText[iLen],charsmax(szText) - iLen,"^n\%c2. \wDelete a \yNPC \d(\rNearby\d)^n",g_iEntities ? 'r' : 'd');
	
	iLen += formatex(szText[iLen],charsmax(szText) - iLen,"\%c3. \wDelete a \yNPC \d(\rBy Aim\d)^n",g_iEntities ? 'r' : 'd');
	
	iLen += formatex(szText[iLen],charsmax(szText) - iLen,"^n\%c4. \wDelete all of \yNPC's map^n",g_iEntities ? 'r' : 'd');
	
	iLen += formatex(szText[iLen],charsmax(szText) - iLen,"\%c5. \wDelete all of \yNPC's server^n",get_user_access(iIndex) >= ServerManager ? 'r' : 'd');
	
	iLen += formatex(szText[iLen],charsmax(szText) - iLen,"^n\r0. \wExit \yNPC Manager Menu");
	
	if(g_iEntities < NPC_MAX_AMOUNT_OF_NPCS)
		iKeys |= (1 << 0);
	
	if(g_iEntities)
		iKeys |= (1 << 1) | (1 << 2) | (1 << 3);
		
	if(get_user_access(iIndex) >= ServerManager)
			iKeys |= (1 << 4);
	
	iKeys |= (1 << 9);
	
	display_menu(iIndex,iKeys,szText,"handler_NPC");
	
	return PLUGIN_HANDLED;
}

public handler_NPC(const iIndex, const iKey)
{
	switch((iKey + 1) % 10)
	{
		case 0:
			return PLUGIN_HANDLED;
		
		case 1:
		{
			if(g_iEntities >= NPC_MAX_AMOUNT_OF_NPCS)
			{
				client_print_color(iIndex,print_team_default,"^4[%s] ^1The amount of npcs has been reached max.",PREFIX);
				
				return menu_NPC(iIndex);
			}
			
			new Float:fOrigin[3],Float:fOrigin2[3];
			entity_get_vector(iIndex,EV_VEC_origin,fOrigin);
			
			new iSize = ArraySize(g_aNpcIDs);
			
			new tData[eNpcData],iEntity,szTemp[10];
			
			for(new i,j; i < iSize; i++)
			{
				iEntity = ArrayGetCell(g_aNpcIDs,i);
				num_to_str(iEntity,szTemp,charsmax(szTemp));
				
				TrieGetArray(g_tNpcs,szTemp,tData,sizeof tData);
				
				for(j = 0; j < 3; j++)
					fOrigin2[j] = tData[nd_fOrigin][j];
				
				if(get_distance_f(fOrigin,fOrigin2) < NPC_MIN_NPCS_DISTANCE)
				{
					client_print_color(iIndex,print_team_default,"^4[%s] ^1You are too close to another ^3NPC^1.",PREFIX);
				
					return menu_NPC(iIndex);
				}
			}
			
			new Float:fAngles[3];
			entity_get_vector(iIndex,EV_VEC_angles,fAngles);
			
			cmd_CreateNPC(fOrigin,fAngles);
			
			fOrigin[2] += (g_fMinSize[2] - g_fMaxSize[2]) * -1.0;
			
			entity_set_vector(iIndex,EV_VEC_origin,fOrigin);
			
			client_print_color(iIndex,print_team_default,"^4[%s] ^1You have successfully created new ^3NPC^1.",PREFIX);
		}
		
		case 2:
			cmd_DeleteNPC(iIndex);
			
		case 3:
			cmd_DeleteNPC(iIndex,true);
			
		case 4:
			cmd_DeleteAllNPC(iIndex);
			
		case 5:
			cmd_DeleteAllNPC(iIndex,true);
	}
	
	cmd_SaveFile();
	
	return menu_NPC(iIndex);
}

public menu_TouchNPC(const iEntity, const iIndex)
{
	if(!is_valid_ent(iEntity))
		return;
		
	static szClassname[32];
	entity_get_string(iEntity,EV_SZ_classname,szClassname,charsmax(szClassname));
	
	if(!equal(szClassname,g_szEntityClassname))
		return;
		
	if(halflife_time() - entity_get_float(iEntity,EV_FL_fuser1) < NPC_CREATED_NPC_DELAY_USE)
		return;
	
	if(!is_user_alive(iIndex))
	{
		client_print_color(iIndex,print_team_default,"^4[%s] ^1You have to be alive to use the ^3NPC^1.",PREFIX);
		
		return;
	}
	
	entity_set_float(iEntity,EV_FL_fuser1,halflife_time() - NPC_CREATED_NPC_DELAY_USE + 0.5);
	
	static iReturn;
	
	ExecuteForward(g_hForwards[FWD_NPCTOUCHED],iReturn,iIndex,iEntity);
	
	new szText[512],iLen,iSize,aData[eItemData],iKeys;
	
	iLen += formatex(szText[iLen],charsmax(szText) - iLen, "\r[ \w%s \r] \wNPC Helper Menu^n\dChoose your favorite option:^n^n",PREFIX);
	
	iSize = ArraySize(g_aItems);
	
	for(new i; i < iSize; i++)
	{
		ArrayGetArray(g_aItems,i,aData,sizeof aData);
		
		iLen += formatex(szText[iLen],charsmax(szText) - iLen, "\r%i. \w%s^n",i + 1, aData[id_szItem]);
		
		iKeys |= (1 << i);
	}
	
	iLen += formatex(szText[iLen],charsmax(szText) - iLen, "^n\r0. \wExit \yNPC Helper Menu");
	
	iKeys |= (1 << 9);
	
	display_menu(iIndex,iKeys,szText,"handler_TouchNPC");
}

public handler_TouchNPC(const iIndex, const iKey)
{
	if((iKey + 1) % 10 == 0)
		return;
	
	if(!is_user_alive(iIndex))
	{
		client_print_color(iIndex,print_team_default,"^4[%s] ^1You have to be alive to use the ^3NPC^1.",PREFIX);
		
		return;
	}
	
	static iReturn,aData[eItemData];
	
	ArrayGetArray(g_aItems,iKey,aData,sizeof aData);
		
	ExecuteForward(g_hForwards[FWD_NPCITEMCHOSEN],iReturn,iIndex,aData[id_iID]);
}

stock cmd_CreateNPC(const Float:fOrigin[3], const Float:fAngles[3])
{	
	new iEntity = create_entity("info_target");
	
	entity_set_string(iEntity,EV_SZ_classname,g_szEntityClassname);
	entity_set_model(iEntity,g_szEntityModel);
	
	entity_set_vector(iEntity,EV_VEC_origin,fOrigin);
	
	entity_set_int(iEntity,EV_INT_solid,SOLID_BBOX);
	
	entity_set_size(iEntity,g_fMinSize,g_fMaxSize);
	
	entity_set_float(iEntity, EV_FL_animtime, get_gametime());
	entity_set_float(iEntity, EV_FL_framerate, 1.5);
	entity_set_int(iEntity, EV_INT_sequence, 1);
	
	entity_set_vector(iEntity,EV_VEC_angles,fAngles);
	entity_set_float(iEntity,EV_FL_fuser1,halflife_time());
	
	new szEntity[5],tData[eNpcData];
	num_to_str(iEntity,szEntity,charsmax(szEntity));
	
	static i;
	
	for(i = 0; i < 3; i++)
	{
		tData[nd_fOrigin][i] = fOrigin[i];
		tData[nd_fAngles][i] = fAngles[i];	
	}
	
	ArrayPushCell(g_aNpcIDs,iEntity);
	TrieSetArray(g_tNpcs,szEntity,tData,sizeof tData);
	
	g_iEntities++;
	
	return iEntity;
}

stock cmd_DeleteNPC(const iIndex, const bool: bAim = false)
{	
	static iEntity,iItem,iReturn,iSize,szEntity[10],szClassname[32],Float:fOrigin[3],Float:fOrigin2[3],tData[eNpcData];
	
	iEntity = -1;
	iItem = -1;

	entity_get_vector(iIndex,EV_VEC_origin,fOrigin);
	
	iSize = ArraySize(g_aNpcIDs);
	
	if(bAim)
	{
		get_user_aiming(iIndex,iEntity,iReturn);
		
		for(new i; i < iSize; i++)
		{
			if(ArrayGetCell(g_aNpcIDs,i) == iEntity)
			{
				iItem = i;
				num_to_str(iEntity,szEntity,charsmax(szEntity));
				
				break;
			}
		}
	}
	
	else
	{
		for(new i,j; i < iSize; i++)
		{
			num_to_str(ArrayGetCell(g_aNpcIDs,i),szEntity,charsmax(szEntity));
			
			TrieGetArray(g_tNpcs,szEntity,tData,sizeof tData);
			
			for(j = 0; j < 3; j++)
				fOrigin2[j] = tData[nd_fOrigin][j];
			
			if(get_distance_f(fOrigin,fOrigin2) < NPC_MIN_DELETE_DISTANCE)
			{
				iItem = i;
				iEntity = str_to_num(szEntity);
				
				break;
			}
		}
	}
	
	if(!is_valid_ent(iEntity) || iItem == -1)
	{
		client_print_color(iIndex,print_team_default,"^4[%s] ^1The ^3NPC ^1cannot be found.",PREFIX);
		
		return;
	}
	
	entity_get_string(iEntity,EV_SZ_classname,szClassname,charsmax(szClassname));
	
	if(!equal(szClassname,g_szEntityClassname))
	{
		client_print_color(iIndex,print_team_default,"^4[%s] ^1The ^3NPC ^1cannot be found.",PREFIX);
		
		return;
	}
	
	remove_entity(iEntity);
	ArrayDeleteItem(g_aNpcIDs,iItem);
	TrieDeleteKey(g_tNpcs,szEntity);
	g_iEntities --;
	
	client_print_color(iIndex,print_team_default,"^4[%s] ^1You have successfully deleted the ^3NPC^1.",PREFIX);
}

stock cmd_DeleteAllNPC(const iIndex, bool:bServer = false)
{
	static iEntity;
	
	iEntity = find_ent_by_class(-1,g_szEntityClassname);
	
	while(is_valid_ent(iEntity))
	{
		remove_entity(iEntity);
		iEntity = find_ent_by_class(-1,g_szEntityClassname);
	}
	
	ArrayClear(g_aNpcIDs);
	TrieClear(g_tNpcs);
	
	g_iEntities = 0;
	
	if(bServer)
	{
		delete_file(g_szFile);
		
		client_print_color(iIndex,print_team_default,"^4[%s] ^1You have successfully deleted all of ^3NPC's server^1.",PREFIX);
		return;
	}
	
	client_print_color(iIndex,print_team_default,"^4[%s] ^1You have successfully deleted all of ^3NPC's map^1.",PREFIX);
}

stock cmd_LoadFile()
{
	if(!file_exists(g_szFile))
		return;
	
	new f = fopen(g_szFile,"rt");
	
	new szBuffer[128],tData[eNpcData],szTemp[10],Float:fOrigin[3],Float:fAngles[3];
	
	static i,szMap[20],Float:fTemp;
	
	while(fgets(f,szBuffer,charsmax(szBuffer)))
	{
		if(szBuffer[0] == EOS)
			continue;
		
		argbreak(szBuffer,szMap,charsmax(szMap),szBuffer,charsmax(szBuffer));
		
		if(!equal(g_szMap,szMap))
			continue;
		
		for(i = 0; i < 6; i++)
		{
			argbreak(szBuffer,szTemp,charsmax(szTemp),szBuffer,charsmax(szBuffer));
			fTemp = str_to_float(szTemp);
			
			if(i < 3)
			{
				tData[nd_fOrigin][i] = fTemp;
				fOrigin[i] = fTemp;
			}
			else
			{
				tData[nd_fAngles][i - 3] = fTemp;
				fAngles[i - 3] = fTemp;
			}
		}
		
		cmd_CreateNPC(fOrigin,fAngles);
	}
	
	fclose(f);
}

stock cmd_SaveFile()
{
	new f = fopen(g_szFile,"rt");
	new f2 = fopen(g_szTempFile,"wt");
	
	new szBuffer[128],tData[eNpcData];
	
	static szMap[20];
	
	while(fgets(f,szBuffer,charsmax(szBuffer)))
	{
		if(szBuffer[0] == EOS)
			continue;
		
		parse(szBuffer,szMap,charsmax(szMap));
		
		if(equal(g_szMap,szMap))
			continue;
		
		fputs(f2,szBuffer);
	}
	
	static i,iSize,iEntity,szTemp[20],j;
	
	iSize = ArraySize(g_aNpcIDs);
	
	for(i  = 0; i < iSize; i++)
	{
		formatex(szBuffer,charsmax(szBuffer),"%s ",g_szMap);
		
		iEntity = ArrayGetCell(g_aNpcIDs,i);
		num_to_str(iEntity,szTemp,charsmax(szTemp));
		
		TrieGetArray(g_tNpcs,szTemp,tData,sizeof tData);
		
		for(j = 0; j < 6; j++)
		{	
			formatex(szTemp,charsmax(szTemp),"%.2f ",tData[j]);
			add(szBuffer,charsmax(szBuffer),szTemp);
		}
		
		add(szBuffer,charsmax(szBuffer)," ^n");
		
		fputs(f2,szBuffer);
	}
	
	fclose(f);
	fclose(f2);
	
	delete_file(g_szFile);
	
	while(!rename_file(g_szTempFile,g_szFile,1)) {}
	
	return PLUGIN_HANDLED;
}
