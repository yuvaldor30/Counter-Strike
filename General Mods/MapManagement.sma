/* Plugin generated by AMXX-Studio */

#include "amxmodx.inc"
#include "engine.inc"
#include "oldmenus.inc"
#include "accounts.inc"

#define PLUGIN "Map Management"
#define VERSION "1.0"
#define AUTHOR "author"

#define TIME_TO_NEXT_VOTE 45 // Minutes

#define MAX_MAP_LENGTH 32

#define MIN_MAPS 4
#define MAX_MAPS 6

#define PREFIX "Maps Management"

#pragma semicolon 1

enum _: eStatuses
{
	STATUS_RUNNING,
	STATUS_NOTIMELEFT,
	STATUS_VOTING,
	STATUS_CHANGEMAP
}

enum _: ePlayerData
{
	pd_bExtend,
	pd_iMap,
	pd_iVoted,
	Array:pd_aMaps
}

enum _: eVoteData
{
	vd_iMapsAmount,
	vd_iMaps[MAX_MAPS],
	vd_iVotes[MAX_MAPS]
}

new Array:g_aMaps = Invalid_Array;

new g_iMaps;

new g_iActivateAt;

new g_iEntity;

new g_szEntityClassname[] = "map_management";

new g_iStatus;

new g_szFile[] = "addons/amxmodx/data/map_list.txt";

new bool:g_bPaused;

new g_szNextMap[MAX_MAP_LENGTH];

new g_iData[MAX_PLAYERS + 1][ePlayerData],g_iVoteData[eVoteData];

public plugin_init() {
	register_plugin(PLUGIN, VERSION, AUTHOR);
	
	while(g_aMaps == Invalid_Array)
		g_aMaps = ArrayCreate(MAX_MAP_LENGTH);
	
	g_iMaps = cmd_LoadFile();
	cmd_SaveFile();
	
	g_iActivateAt = floatround(get_gametime()) + TIME_TO_NEXT_VOTE * 60;
	
	g_iEntity = create_entity("info_target");
	
	entity_set_string(g_iEntity,EV_SZ_classname,g_szEntityClassname);
	register_think(g_szEntityClassname,"think_Entity");
	
	cmd_NextThinkIn();
	
	register_clcmd("say /nextmap","cmd_Status");
	register_clcmd("say /timeleft","cmd_Status");
	
	register_clcmd("say /togglemaps","cmd_PauseTimer");
	
	register_clcmd("say /managemaps","menu_ManageMain");
	
	register_clcmd("maps_addmap","cmd_AddMap");
	
	
	register_logevent("event_RoundEnd", 2, "1=Round_End");
}

public think_Entity(const iEntity)
{
	if(iEntity == g_iEntity)
	{
		if(!(g_iActivateAt - floatround(get_gametime())))
		{
			g_iStatus = STATUS_NOTIMELEFT;
			
			cmd_Status(0);
		}
			
	}
}

public event_RoundStart()
{
	if(g_iStatus == STATUS_VOTING)
		//cmd_StartVote();
}

public event_RoundEnd()
{
	if(g_bPaused)
		return;

	cmd_Status(0);

	if(g_iStatus == STATUS_NOTIMELEFT)
		g_iStatus = STATUS_VOTING;
	
	else if(g_iStatus == STATUS_CHANGEMAP)
	{
		server_cmd("amx_map %s",g_szNextMap);
		
		client_print_color(0,print_team_default,"^4[%s] ^1The server is changing map to ^3%s^1.",PREFIX,g_szNextMap);
	}
}

public client_authorized(iIndex)
{
	arrayset(g_iData[iIndex],0,sizeof g_iData[]);
	
	while(g_iData[iIndex][pd_aMaps] == Invalid_Array)
		g_iData[iIndex][pd_aMaps] = ArrayCreate();
		
	ArrayClear(g_iData[iIndex][pd_aMaps]);
}

public cmd_AddMap(const iIndex)
{
	new szMap[MAX_MAP_LENGTH];
	read_argv(1,szMap,charsmax(szMap));
	
	if(!is_map_valid(szMap))
		client_print_color(iIndex,print_team_default,"^4[%s] ^1The map ^3%s ^1is not exist at server's maps.",PREFIX,szMap);
	
	else if(cmd_ArrayFindMap(g_aMaps,szMap) != -1)
		client_print_color(iIndex,print_team_default,"^4[%s] ^1The map ^3%s ^1is already exist at maps list.",PREFIX,szMap);
		
	else
	{	
		g_iData[iIndex][pd_iMap] = ArrayPushString(g_aMaps,szMap);
		
		menu_ViewMap(iIndex);
		
		client_print_color(iIndex,print_team_default,"^4[%s] ^1You have successfully added the map ^3%s ^1to maps list.",PREFIX,szMap);
		
		g_iMaps ++;
		
		cmd_SaveFile();
		
		client_cmd(iIndex,"messagemode maps_addmap");
		
		return;
	}
	
	menu_ManageMain(iIndex);
}

public menu_ManageMain(const iIndex)
{
	if(get_user_access(iIndex) < Administrator)
	{
		client_print_color(iIndex,print_team_default,"^4[%s] ^1You have no access to this command.",PREFIX);
	
		return PLUGIN_HANDLED;
	}
	
	new szText[512],iLen;
	
	
	iLen += formatex(szText[iLen],charsmax(szText) - iLen,"\r[ \w%s \r] \wMaps Management Main Menu^n\dChoose your favorite option:^n^n",PREFIX);
	
	iLen += formatex(szText[iLen],charsmax(szText) - iLen,"\r1. \wView Maps List^n");
	iLen += formatex(szText[iLen],charsmax(szText) - iLen,"\r2. \wAdd New Map^n");
	iLen += formatex(szText[iLen],charsmax(szText) - iLen,"\r3. \wStart Custom Vote^n");
	iLen += formatex(szText[iLen],charsmax(szText) - iLen,"\r4. \wStart Random Vote^n");
	iLen += formatex(szText[iLen],charsmax(szText) - iLen,"\r4. \wStart Random Vote^n");
	iLen += formatex(szText[iLen],charsmax(szText) - iLen,"\r4. \wStart Random Vote^n");
	
	iLen += formatex(szText[iLen],charsmax(szText) - iLen,"^n\r0. \wExit \yMaps Management Main Menu^n");
	
	new iKeys = (1 << 0) | (1 << 1) | (1 << 2)  | (1 << 3) | (1 << 9);
	
	display_menu(iIndex,iKeys,szText,"handler_ManageMain");
	
	return PLUGIN_HANDLED;
}

public handler_ManageMain(const iIndex, const iKey)
{
	switch((iKey + 1) % 10)
	{
		case 0:
			return;
			
		case 1:
			menu_Maps(iIndex);
			
		case 2:
			client_cmd(iIndex,"messagemode maps_addmap");
			
		case 3:
			menu_CustomVoteManagement(iIndex);
			
		case 4:
			menu_RandomVoteManagement(iIndex);
		
	}
}

public menu_CustomVoteManagement(const iIndex)
{
	new szText[512],iLen;
	
	iLen += formatex(szText[iLen],charsmax(szText) - iLen,"\r[ \w%s \r] \wCustom Vote Management^n\dChoose your favorite terms:^n^n",PREFIX);
	
	iLen += formatex(szText[iLen],charsmax(szText) - iLen,"\r1. \wView Maps List^n");
	iLen += formatex(szText[iLen],charsmax(szText) - iLen,"\r2. \wAdd New Map^n");
	iLen += formatex(szText[iLen],charsmax(szText) - iLen,"\r3. \wStart Custom Vote^n");
	
	iLen += formatex(szText[iLen],charsmax(szText) - iLen,"^n\r0. \Back to \yMaps Management Main Menu^n");
	
	new iKeys = (1 << 0) | (1 << 1) | (1 << 2) | (1 << 9);
	
	display_menu(iIndex,iKeys,szText,"handler_ManageMain");
	
	return PLUGIN_HANDLED;
	
}

public menu_Maps(const iIndex)
{
	new szText[192];
	
	formatex(szText,charsmax(szText),"\r[ \w%s \r] \wMaps List Menu^n^n \d- \yTotal Maps Amount: \w%i\d.^n \d- \yTotal Selected Amount: \r%i\d/\r%i\d.%s",PREFIX,g_iMaps,ArraySize(g_iData[iIndex][pd_aMaps]),MAX_MAPS, ArraySize(g_aMaps) > 7 ? "^n^n\d- \rPage:\w" : "");
	new iMenu = menu_create(szText,"handler_Maps");
	
	for(new i; i < g_iMaps; i++)
	{
		ArrayGetString(g_aMaps,i,szText,sizeof szText);
		
		if(ArrayFindValue(g_iData[iIndex][pd_aMaps],i) != -1)
			add(szText,charsmax(szText)," \d(\ySelected\d)");
		
		menu_additem(iMenu,szText);
	}
	
	if(!menu_items(iMenu))
	{
		client_print_color(iIndex,print_team_default,"^4[%s] ^1The server has not uploaded any map yet.",PREFIX);
		
		menu_ManageMain(iIndex);
	}
	
	else
	{
		menu_setprop(iMenu,MPROP_EXITNAME,"Back to \yMaps Managements Main Menu");
		
		menu_display(iIndex,iMenu);
	}
	
}

public handler_Maps(const iIndex, const iMenu, const iItem)
{
	menu_destroy(iMenu);
	
	if(iItem == MENU_EXIT)
	{
		menu_ManageMain(iIndex);
		
		return;
	}
		
	g_iData[iIndex][pd_iMap] = iItem;
		
	menu_ViewMap(iIndex);
}

public menu_ViewMap(const iIndex)
{
	new szText[512],iLen,iKeys,szMap[MAX_MAP_LENGTH];
	
	ArrayGetString(g_aMaps,g_iData[iIndex][pd_iMap],szMap,sizeof szMap);
	
	iLen += formatex(szText[iLen],charsmax(szText) - iLen,"\r[ \w%s \r] \wView Map Menu^n\wYou are viewing \y%s\w's map^n^n",PREFIX,szMap);
	
	if(ArrayFindValue(g_iData[iIndex][pd_aMaps],g_iData[iIndex][pd_iMap]) == -1 && g_iData[iIndex][pd_iMapsAmount] < MAX_MAPS)
	{
		iLen += formatex(szText[iLen],charsmax(szText) - iLen,"\r1. \wAdd to custom vote\d.^n");
		iKeys |= (1 << 0);
	}
	
	else
		iLen += formatex(szText[iLen],charsmax(szText) - iLen,"\d1. \wAdd to custom vote\d.^n");
		
	if(ArrayFindValue(g_iData[iIndex][pd_aMaps],g_iData[iIndex][pd_iMap]) != -1)
	{
		iLen += formatex(szText[iLen],charsmax(szText) - iLen,"\r2. \wRemove from custom vote\d.^n");
		iKeys |= (1 << 1);
	}
	
	else
		iLen += formatex(szText[iLen],charsmax(szText) - iLen,"\d2. \wRemove from custom vote\d.^n");
	
	iLen += formatex(szText[iLen],charsmax(szText) - iLen,"^n\r3. \wDelete from maps list\d.^n");
	
	iLen += formatex(szText[iLen],charsmax(szText) - iLen,"^n\r0. \wExit \yMaps List Menu^n");
	
	iKeys |= (1 << 2) | (1 << 9);
	
	display_menu(iIndex,iKeys,szText,"handler_ViewMap");
}

public handler_ViewMap(const iIndex, const iKey)
{
	if((iKey + 1) % 10 == 0)
	{
		menu_Maps(iIndex);
		
		return;
	}
	
	new szMap[MAX_MAP_LENGTH];
	ArrayGetString(g_aMaps,g_iData[iIndex][pd_iMap],szMap,sizeof szMap);
	
	
	switch((iKey + 1) % 10)
	{
		case 1:
		{
			ArrayPushCell(g_iData[iIndex][pd_aMaps],g_iData[iIndex][pd_iMap]);
			
			g_iData[iIndex][pd_iMapsAmount] ++;
			
			client_print_color(iIndex,print_team_default,"^4[%s] ^1You have successfully added the map ^3%s ^1to your custom list.",PREFIX,szMap);
		}
		
		case 2:
		{
			ArrayDeleteItem(g_iData[iIndex][pd_aMaps],ArrayFindValue(g_iData[iIndex][pd_aMaps],g_iData[iIndex][pd_iMap]));
			
			g_iData[iIndex][pd_iMapsAmount] --;
			
			client_print_color(iIndex,print_team_default,"^4[%s] ^1You have successfully removed the map ^3%s ^1from your custom list.",PREFIX,szMap);
		}
		
		case 3:
		{
			ArrayDeleteItem(g_aMaps,g_iData[iIndex][pd_iMap]);
						
			g_iMaps --;
			
			cmd_SaveFile();
			
			client_print_color(iIndex,print_team_default,"^4[%s] ^1You have successfully deleted the map ^3%s ^1from the maps list.",PREFIX,szMap);
		}
	}
	
	menu_Maps(iIndex);
}

public cmd_Status(const iIndex)
{
	if(g_bPaused)
		client_print_color(iIndex,print_chat,"^4[%s] ^1The map status has been paused at:",PREFIX);
	
	{
		switch(g_iStatus)
		{
			case STATUS_RUNNING:
				client_print_color(iIndex,print_team_default,"^4[%s] ^1The vote maps will be started in %s^1.",PREFIX,cmd_CompareTime(g_iActivateAt));
			
			case STATUS_NOTIMELEFT:
				client_print_color(iIndex,print_team_default,"^4[%s] ^1The vote maps will be started next round.",PREFIX);
			
			case STATUS_VOTING:
				client_print_color(iIndex,print_team_default,"^4[%s] ^1The vote maps is currently running.",PREFIX);
			
			case STATUS_CHANGEMAP:
				client_print_color(iIndex,print_team_default,"^4[%s] ^1The vote maps has been decided as win to the map ^3%s^1.",PREFIX,g_szNextMap);
		}
	}
	
	return PLUGIN_HANDLED;
}

public cmd_PauseTimer(const iIndex)
{
	if(get_user_access(iIndex) < Administrator)
	{
		client_print_color(iIndex,print_team_default,"^4[%s] ^1You have no access to this command.",PREFIX);
	
		return PLUGIN_HANDLED;
	}
	
	g_bPaused = !g_bPaused;
	
	if(g_bPaused)
		g_iActivateAt -= floatround(get_gametime());
		
	else
		g_iActivateAt += floatround(get_gametime());
	
	if(g_iStatus == STATUS_VOTING)
		g_iStatus = STATUS_NOTIMELEFT;
	
	new szName[MAX_NAME_LENGTH];
	get_user_name(iIndex,szName,charsmax(szName));
	
	for(new i = 1; i <= MaxClients; i++)
	{
		if(!is_user_connected(i))
			continue;
			
		if(i == iIndex)	
			client_print_color(i,print_team_default,"^4[%s] ^1You have %spaused the maps management.",PREFIX, g_bPaused ? "" : "un");
			
		else
			client_print_color(i,print_team_default,"^4[%s] ^3%s ^1has %spaused the maps management.",PREFIX,szName, g_bPaused ? "" : "un");
	}
	
	cmd_NextThinkIn();
	
	return PLUGIN_HANDLED;
}

stock cmd_NextThinkIn()
{
	new iTime = 999999;
	
	if(!g_bPaused)
	{
		iTime = g_iActivateAt - floatround(get_gametime());
		
		if(iTime < 0)
			iTime = 999999;
	}
		
	entity_set_float(g_iEntity,EV_FL_nextthink,halflife_time() + float(iTime));
}
/*
stock cmd_MapChosen(const iIndex, const iMap)
{
	for(new i; i < g_iMaps; i++)
	{
		if(ArrayGetCell(g_iData[iIndex][pd_aMaps],i) == iMap)
			return true;
	}
	
	return false;
}*/ //ArrayFindValue(g_iData[iIndex][pd_aMaps],iMap) != - 1

stock cmd_CompareTime(iTime)
{
	
	if(!g_bPaused)
		iTime -= floatround(get_gametime());
		
	new aTime[2],szTime[32],iLen;
	
	aTime[0] = iTime / 60;
	aTime[1] = iTime % 60;
	
	if(aTime[0])
		iLen = formatex(szTime,charsmax(szTime),"^4%d ^1minute%s",aTime[0],aTime[0] == 1 ? "" : "s");
		
	if(aTime[1])
		formatex(szTime[iLen],charsmax(szTime) - iLen,"%s^4%d ^1second%s",iLen ? "^1, " : "",aTime[1],aTime[1] == 1 ? "" : "s");
		
	return szTime;
}

stock cmd_ArrayFindMap(Array:which, const item[])
{
	new iItem = ArrayFindString(which,item);
	
	if(iItem != -1)
	{
		new szMap[MAX_MAP_LENGTH];
		
		ArrayGetArray(which,iItem,szMap,charsmax(szMap));
		
		if(equali(szMap,item))
			return iItem;
		
	}
	
	return -1;
}

stock cmd_LoadFile()
{
	if(!file_exists(g_szFile))
	{
		log_amx("[%s] The file cannot be found, (%s)",PLUGIN,g_szFile);
		
		return 0;
	}
	
	new f = fopen(g_szFile,"rt");
	
	new szBuffer[64];
	
	while(fgets(f,szBuffer,charsmax(szBuffer)))
	{
		replace(szBuffer,charsmax(szBuffer),"^n","");
		trim(szBuffer);
		
		if(szBuffer[0] == EOS)
			continue;
		
		if(!is_map_valid(szBuffer))
			continue;
		
		ArrayPushString(g_aMaps,szBuffer);
	}
	
	fclose(f);
	
	return ArraySize(g_aMaps);
}

stock cmd_SaveFile()
{
	delete_file(g_szFile);
	
	new f = fopen(g_szFile,"wt");
	
	new szBuffer[64];
	
	for(new i; i < g_iMaps; i++)
	{
		ArrayGetString(g_aMaps,i,szBuffer,sizeof szBuffer);
		
		add(szBuffer,charsmax(szBuffer)," ^n");
		
		fputs(f,szBuffer);
	}
	
	fclose(f);
}
/* AMXX-Studio Notes - DO NOT MODIFY BELOW HERE
*{\\ rtf1\\ ansi\\ deff0{\\ fonttbl{\\ f0\\ fnil Tahoma;}}\n\\ viewkind4\\ uc1\\ pard\\ lang2057\\ f0\\ fs16 \n\\ par }
*/
