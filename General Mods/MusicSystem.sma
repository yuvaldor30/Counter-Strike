/* Plugin generated by AMXX-Studio */

#include "amxmodx.inc"
#include "fvault.inc"
#include "oldmenus.inc"
#include "music_api.inc"

#define PLUGIN "Music System"
#define VERSION "1.0"
#define AUTHOR "MJ"

#define MUSIC_AMOUNT_OF_CHORUSES 31

#define MUSIC_VOLUME_STEP 0.1
#define MUSIC_MAX_VOLUME 1.0

#define PREFIX "Music System"

#pragma semicolon 1

enum _: eSongData
{
	sd_szFile[64],
	sd_szSong[64],
	sd_szAuthor[64]
}

enum _: ePlayerData
{
	pd_iSong,
	Float:pd_fVolume
}

new Array: g_aSongs = Invalid_Array;
new Array: g_aChoruses = Invalid_Array;

new const g_szFileVault[] = "music_Data";

new const g_szSongsFile[] = "addons/amxmodx/data/music_list.txt";
new const g_szLocation[] = "iPlay/ZombieSwarm/Music";

new const g_szChorusFormat[] = "winsound";

new const g_szSongEnd[] = "mp3";
new const g_szChorusEnd[] = "mp3";

new g_iSongs, g_iChoruses;

new g_aData[MAX_PLAYERS + 1][ePlayerData];

new g_iData[MAX_PLAYERS + 1][eSOUNDS];

public plugin_init() {
	register_plugin(PLUGIN, VERSION, AUTHOR);
	
	register_event("HLTV","event_OnNewRound", "a", "1=0", "2=0");
	
	register_clcmd("say /sound","menu_Sounds");
	register_clcmd("say /music","menu_MusicMain");
	register_clcmd("say /stop","cmd_StopMusic");
	register_clcmd("say /stopmusic","cmd_StopMusic");
	register_clcmd("say /pause","cmd_StopMusic");
	register_clcmd("say /pausemusic","cmd_StopMusic");
}

public plugin_natives()
{
	register_native("music_SoundEnabled","native_SoundEnabled");
	register_native("music_RandomSong","native_RandomSong");
	register_native("music_RandomChorus","native_RandomChorus");
}

public native_SoundEnabled(const iParams,const iPluginID)
{
	new iRequiredParams = 2;
	
	if(iParams < iRequiredParams)
	{
		log_error(AMX_ERR_NATIVE,"[%s] cannot find enought parameters. %i/%i",PLUGIN ,iParams, iRequiredParams);
		return PLUGIN_CONTINUE;
	}
	
	new iIndex = get_param(1);
	new iSound = get_param(2);
	
	return g_iData[iIndex][iSound];
}

public native_RandomSong(const iParams,const iPluginID)
{
	new iRequiredParams = 1;
	
	if(iParams < iRequiredParams)
	{
		log_error(AMX_ERR_NATIVE,"[%s] cannot find enought parameters. %i/%i",PLUGIN ,iParams, iRequiredParams);
		return;
	}
	
	new iIndex = get_param(1);
	
	g_aData[iIndex][pd_iSong] = random_num(0,g_iSongs);
	
	cmd_PlaySong(iIndex);
}

public native_RandomChorus(const iParams,const iPluginID)
{
	new iRequiredParams = 1;
	
	if(iParams < iRequiredParams)
	{
		log_error(AMX_ERR_NATIVE,"[%s] cannot find enought parameters. %i/%i",PLUGIN ,iParams, iRequiredParams);
		return;
	}
	
	new iIndex = get_param(1);
	
	//client_cmd(iIndex,";mp3volume %.2f",g_aData[iIndex][pd_fVolume]);
	cmd_PlayRandomChorus(iIndex);
}

public plugin_precache()
{
	while(g_aSongs == Invalid_Array)
		g_aSongs = ArrayCreate(eSongData);
		
	g_iSongs = cmd_LoadSongs();
		
	while(g_aChoruses == Invalid_Array)
		g_aChoruses = ArrayCreate();
	
	g_iChoruses = cmd_LoadChoruses();
	
	if(!g_iSongs && !g_iChoruses)
		set_fail_state("[%s] Songs & Choruses cannot be found",PLUGIN);
}

public event_OnNewRound()
{
	for(new i = 1; i <= MaxClients; i++)
	{
		if(!is_user_connected(i))
			continue;
		
		if(g_iData[i][SOUND_WINNING] || g_iData[i][SOUND_AUTOMUSIC])
			client_cmd(i,"mp3 stop");
	}
}

public client_authorized(iIndex)
{
	g_aData[iIndex][pd_iSong] = 0;
	g_aData[iIndex][pd_fVolume] = 1.0 - 3 * MUSIC_VOLUME_STEP;
	client_cmd(iIndex,";mp3volume %.2f",g_aData[iIndex][pd_fVolume]);

	arrayset(g_iData[iIndex],1,sizeof g_iData[]);
	
	cmd_LoadData(iIndex);
}

public menu_Sounds(const iIndex)
{
	new szText[512],iLen,iKeys;
	
	iLen += formatex(szText[iLen], charsmax(szText) - iLen,"\r[ \w%s \r] \wSound Settings Menu^n\dSet yourself settings as you want:^n^n",PREFIX);
	
	for(new i; i < eSOUNDS; i++)
	{
		iLen += formatex(szText[iLen], charsmax(szText) - iLen,"\r%i. \y%s \wSound: %s^n",i + 1,music_GetSoundName(i),g_iData[iIndex][i] ? "\rON" : "\dOFF");
		iKeys |= (1 << i);
	}
		
	iLen += formatex(szText[iLen], charsmax(szText) - iLen,"^n\r0. \wExit \ySound Settings Menu");
	iKeys |= (1 << 9);
	
	display_menu(iIndex,iKeys,szText,"handler_Sounds");
	
	return PLUGIN_HANDLED;
}

public handler_Sounds(const iIndex, const iKey)
{
	if((iKey + 1) % 10 == 0)
		return;
	
	g_iData[iIndex][iKey] = !g_iData[iIndex][iKey];
	
	client_print_color(iIndex,print_team_default,"^4[%s] ^1You have ^1%s ^3%s ^1sound server.",PREFIX, g_iData[iIndex][iKey] ? "activated" : "deactivated", music_GetSoundName(iKey));
	
	menu_Sounds(iIndex);
	cmd_SaveData(iIndex);
}

public client_disconnected(iIndex)
{
	cmd_SaveData(iIndex);
	arrayset(g_iData[iIndex],1,sizeof g_iData[]);
}

public menu_MusicMain(const iIndex)
{
	if(!g_iSongs)
	{
		client_print_color(iIndex,print_team_default,"^4[%s] ^1The server has not uploaded any song.", PREFIX);
		
		return PLUGIN_HANDLED;
	}
	
	new szText[512],iLen,aData[eSongData];
	
	ArrayGetArray(g_aSongs,g_aData[iIndex][pd_iSong],aData,sizeof aData);
	
	iLen += formatex(szText[iLen], charsmax(szText) - iLen,"\r[ \w%s \r] \wMusic Main Menu^n\dChoose your song's settings as you want:^n^n",PREFIX);
	
	new szTemp[12],iTemp;
	
	iTemp = floatround(g_aData[iIndex][pd_fVolume] * 10.0);
	
	for(new i; i < 10; i++)
		szTemp[i] = i < iTemp ? '+' : '-';
	iLen += formatex(szText[iLen], charsmax(szText) - iLen,"\d- \wCurrent Song: \r%s^n",aData[sd_szSong]);
	iLen += formatex(szText[iLen], charsmax(szText) - iLen,"\d- \wSong's Author: \r%s^n",aData[sd_szAuthor]);
	
	
	iLen += formatex(szText[iLen], charsmax(szText) - iLen,"^n\d- \wCurrent Volume: \d[\y%s\d]^n",szTemp);
	
	iLen += formatex(szText[iLen], charsmax(szText) - iLen,"^n\r1. \wChoose song\d.^n");
	iLen += formatex(szText[iLen], charsmax(szText) - iLen,"\%c2. \wVolume UP \y+\d.^n",g_aData[iIndex][pd_fVolume] < MUSIC_MAX_VOLUME ? 'r' : 'd');
	iLen += formatex(szText[iLen], charsmax(szText) - iLen,"\%c3. \wVolume Down \y-\d.^n",g_aData[iIndex][pd_fVolume] > MUSIC_VOLUME_STEP ? 'r' : 'd');
	
	iLen += formatex(szText[iLen], charsmax(szText) - iLen,"^n\r4. \yPlay \wmusic\d.^n");
	iLen += formatex(szText[iLen], charsmax(szText) - iLen,"\r5. \yPause \wmusic\d.^n");
	
	iLen += formatex(szText[iLen], charsmax(szText) - iLen,"^n\r0. \wExit \yMusin Main Menu");
	
	new iKeys = (1 << 0) | (1 << 3)  | (1 << 4) | (1 << 9);
	
	if(g_aData[iIndex][pd_fVolume] < MUSIC_MAX_VOLUME)
		iKeys |= (1 << 1);
		
	if(g_aData[iIndex][pd_fVolume] > MUSIC_VOLUME_STEP)
		iKeys |= (1 << 2);
	
	display_menu(iIndex,iKeys,szText,"handler_MusicMain");
	
	return PLUGIN_HANDLED;
}

public handler_MusicMain(const iIndex, const iKey)
{
	switch((iKey + 1) % 10)
	{
		case 1:
		{
			menu_MusicSongs(iIndex);
		}
		
		case 2:
		{
			if(g_aData[iIndex][pd_fVolume] < MUSIC_MAX_VOLUME)
			{
				g_aData[iIndex][pd_fVolume] += MUSIC_VOLUME_STEP;
				client_cmd(iIndex,";mp3volume %.2f",g_aData[iIndex][pd_fVolume]);
			}
			
			else
				client_print_color(iIndex,print_team_default,"^4[%s] ^1You have already set the maximium volume.",PREFIX);
				
			menu_MusicMain(iIndex);
		}
		
		case 3:
		{	
			if(g_aData[iIndex][pd_fVolume] > MUSIC_VOLUME_STEP)
			{
				g_aData[iIndex][pd_fVolume] -= MUSIC_VOLUME_STEP;
				client_cmd(iIndex,";mp3volume %.2f",g_aData[iIndex][pd_fVolume]);
			}
			
			
			else
				client_print_color(iIndex,print_team_default,"^4[%s] ^1You have already set the maximium volume.",PREFIX);
				
			menu_MusicMain(iIndex);
		}
		
		case 4:
		{	
			cmd_PlaySong(iIndex);
		}
		
		case 5:
		{
			client_cmd(iIndex,"say /stopmusic");
			
			menu_MusicMain(iIndex);
		}
	}
}

public menu_MusicSongs(const iIndex)
{
	new szText[128],aData[eSongData];
	
	formatex(szText, charsmax(szText),"\r[ \w%s \r] \wMusic Songs Menu^n\dChoose your favorite song:",PREFIX);
	new iMenu = menu_create(szText,"handler_MusicSongs");
	
	for(new i; i < g_iSongs; i++)
	{
		ArrayGetArray(g_aSongs,i,aData,sizeof aData);
		
		menu_additem(iMenu,aData[sd_szSong]);
	}
	
	menu_setprop(iMenu,MPROP_EXITNAME,"Back to \yMusic Main Menu");
	
	menu_display(iIndex,iMenu);
}

public handler_MusicSongs(const iIndex, const iMenu, const iItem)
{
	menu_destroy(iMenu);
	
	if(iItem != MENU_EXIT)
		g_aData[iIndex][pd_iSong] = iItem;
	
	menu_MusicMain(iIndex);
}


public cmd_StopMusic(const iIndex)
{	
	client_cmd(iIndex,"mp3 stop");
	client_print_color(iIndex,print_team_default,"^4[%s] ^1You have paused the music.",PREFIX);
	
	return PLUGIN_HANDLED;
}

stock cmd_PlaySong(iIndex)
{
	if(!g_iSongs)
	{
		client_print_color(iIndex,print_team_default,"^4[%s] ^1The server has not uploaded any song.", PREFIX);
		
		return;
	}
	
	//client_cmd(iIndex,";mp3volume %.2f",g_aData[iIndex][pd_fVolume]);
	
	static aData[eSongData];
	ArrayGetArray(g_aSongs,g_aData[iIndex][pd_iSong],aData,sizeof aData);
	
	client_cmd(iIndex,"mp3 play ^"sound/%s/%s.%s^"",g_szLocation,aData[sd_szFile],g_szSongEnd);
	
	client_print_color(iIndex,print_team_default,"^4[%s] ^1The song ^3%s ^1has been started.",PREFIX,aData[sd_szSong]);
	
	menu_MusicMain(iIndex);
}

stock cmd_PlayRandomChorus(iIndex)
{
	if(!g_iChoruses)
		return;
	
	static iChorus;
	
	iChorus = ArrayGetCell(g_aChoruses,random(g_iChoruses));
	client_cmd(iIndex,"mp3 play ^"sound/%s/%s%s%i.%s^"",g_szLocation,g_szChorusFormat,iChorus < 10 ? "0" : "",iChorus,g_szChorusEnd);
}

stock cmd_LoadData(const iIndex)
{
	static szData[64], szKey[25];
	get_user_authid(iIndex,szKey,charsmax(szKey));
	
	if(fvault_get_data(g_szFileVault,szKey,szData,charsmax(szData)))
	{
		replace_all(szData,charsmax(szData),"#"," ");
		trim(szData);
		
		static szTemp[4];
		
		for(new i; i < eSOUNDS; i++)
		{
			argbreak(szData,szTemp,charsmax(szTemp),szData,charsmax(szData));
			
			g_iData[iIndex][i] = str_to_num(szTemp);
		}
	}
}

stock cmd_SaveData(const iIndex)
{
	static szKey[25];
	get_user_authid(iIndex,szKey,charsmax(szKey));
	
	new szData[64],iLen;
	
	for(new i; i < eSOUNDS; i++)
		iLen += formatex(szData[iLen],charsmax(szData) - iLen,"#%i",g_iData[iIndex][i]);
		
	fvault_set_data(g_szFileVault,szKey,szData);
}

stock cmd_LoadChoruses()
{
	new szTemp[128];
	
	for(new i; i < MUSIC_AMOUNT_OF_CHORUSES; i++)
	{
		formatex(szTemp,charsmax(szTemp),"sound/%s/%s%s%i.%s",g_szLocation,g_szChorusFormat,i < 10 ? "0" : "",i,g_szChorusEnd);
		
		if(file_exists(szTemp))
		{
			ArrayPushCell(g_aChoruses,i);
			
			replace(szTemp,charsmax(szTemp),"sound/","");
			precache_sound(szTemp);
		}
		
		else
			log_amx("[%s] missing file. (%s)",PLUGIN,szTemp);
	}
	
	return ArraySize(g_aChoruses);
}

stock cmd_LoadSongs()
{
	if(!file_exists(g_szSongsFile))
	{
		write_file(g_szSongsFile,"; Add Songs by the next format:");
		write_file(g_szSongsFile,"; ^"FileName (without end)^" ^"Song Name^" ^"Author Name^"");
		return 0;
	}
	
	new f = fopen(g_szSongsFile,"rt");
	
	new szBuffer[256],aData[eSongData],szTemp[128];
	
	while(fgets(f,szBuffer,charsmax(szBuffer)))
	{
		replace(szBuffer,charsmax(szBuffer),"^n","");
		trim(szBuffer);
		
		if(szBuffer[0] == EOS || szBuffer[0] == ';')
			continue;
		
		argbreak(szBuffer,aData[sd_szFile],charsmax(aData[sd_szFile]),szBuffer,charsmax(szBuffer));
		
		formatex(szTemp,charsmax(szTemp),"sound/%s/%s.%s",g_szLocation,aData[sd_szFile],g_szSongEnd);
		
		if(!file_exists(szTemp))
			continue;
			
		else
		{
			replace(szTemp,charsmax(szTemp),"sound/","");
			precache_sound(szTemp);
		}
		
		argbreak(szBuffer,aData[sd_szSong],charsmax(aData[sd_szSong]),aData[sd_szAuthor],charsmax(aData[sd_szAuthor]));
		
		remove_quotes(aData[sd_szAuthor]);
		
		ArrayPushArray(g_aSongs,aData,sizeof aData);
	}
	
	fclose(f);
	
	return ArraySize(g_aSongs);
}
