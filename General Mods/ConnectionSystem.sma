/* Plugin generated by AMXX-Studio */

#include "amxmodx.inc"
#include "engine.inc"
#include "oldmenus.inc"
#include "accounts.inc"
#include "users.inc"

#define PLUGIN "Manage Connections"
#define VERSION "1.0"
#define AUTHOR "MJ"

#define AUTO_CHECK 30.0

#define PREFIX "Connection System"

#pragma semicolon 1

enum _: eModes
{
	MODE_WHITELIST,
	MODE_BLACKLIST,
	MODE_EVERYONE	
}

new const g_szModes[eModes][] =
{
	"White List",
	"Black List",
	"Everyone"
};

enum _: eAutoKey
{
	ak_szKey[25],
	ak_iList
}

enum _: eLists
{
	LIST_WHITE,
	LIST_BLACK
}

new const g_aAutoKeys[][eAutoKey] =
{
	{"STEAM_0:1:58312057",LIST_WHITE}
};

new const g_szMessages[eLists][] =
{
	"This server is currently being built, come later :)",
	"You have been blocked to connect that server."
};

new const g_szFiles[eLists][] =
{
	"addons/amxmodx/data/connections_whitelist.txt",
	"addons/amxmodx/data/connections_blacklist.txt"
};

new Array:g_aKeys[eLists];

new Trie:g_tKeys[eLists];

new g_iCvar;

new g_szEntityClassname[] = "ConnectionManager";

new g_iEntity;

new g_szKey[MAX_PLAYERS + 1][25];

public plugin_init() {
	register_plugin(PLUGIN, VERSION, AUTHOR);
	
	for(new i; i < eLists; i++)
	{
		while(g_aKeys[i] == Invalid_Array)
			g_aKeys[i] = ArrayCreate(25);
			
		while(g_tKeys[i] == Invalid_Trie)
			g_tKeys[i] = TrieCreate();
			
		cmd_LoadFile(i);
	}
	
	cmd_LoadAutoList();
	
	g_iCvar = register_cvar("amx_connectmode","2");	
	
	g_iEntity = create_entity("info_target");
	entity_set_string(g_iEntity,EV_SZ_classname,g_szEntityClassname);
	
	register_think(g_szEntityClassname,"think_Entity");
	
	cmd_SetEntityThink();
	
	register_clcmd("say /manageconnections","menu_ManageMain");
	
	register_clcmd("amx_addkey","cmd_AddKey");
	register_clcmd("amx_removekey","cmd_RemoveKey");
}

public cmd_AddKey(const iIndex)
{
	new szMessage[32];
	
	read_args(szMessage,charsmax(szMessage));
	remove_quotes(szMessage);
	
	trim(szMessage);
	
	static iMode;
	
	iMode = get_pcvar_num(g_iCvar);
	
	if(iMode == MODE_EVERYONE)
	{
		client_print_color(iIndex,print_team_default,"^4[%s] ^1You cannot add key at ^3%s ^1mode.",PREFIX,g_szModes[iMode]);
		
		return;
	}
	
	if(TrieKeyExists(g_tKeys[iMode],szMessage))
	{
		client_print_color(iIndex,print_team_default,"^4[%s] ^1The key ^3%s ^1is already exist in the ^3%s ^1mode.",PREFIX,szMessage,g_szModes[iMode]);
		
		return;
	}
	
	if(!cmd_ValidKey(szMessage))
	{
		client_print_color(iIndex,print_team_default,"^4[%s] ^1The key ^3%s ^1is invalid.",PREFIX,szMessage);
		client_cmd(iIndex,"messagemode amx_addkey");
		return;
	}
	
	ArrayPushString(g_aKeys[iMode],szMessage);
	TrieSetCell(g_tKeys[iMode],szMessage,1);
	
	client_print_color(iIndex,print_team_default,"^4[%s] ^1You have successfully added the key ^3%s ^1to the ^3%s^1.",PREFIX,szMessage,g_szModes[iMode]);
	
	cmd_SaveFile(iMode);
}

public cmd_RemoveKey(const iIndex)
{
	new szMessage[32];
	
	read_args(szMessage,charsmax(szMessage));
	remove_quotes(szMessage);
	
	trim(szMessage);
	
	static iMode;
	
	iMode = get_pcvar_num(g_iCvar);
	
	if(iMode == MODE_EVERYONE)
	{
		client_print_color(iIndex,print_team_default,"^4[%s] ^1You cannot remove key at ^3%s ^1mode.",PREFIX,g_szModes[iMode]);
		
		return;
	}
	
	if(!TrieKeyExists(g_tKeys[iMode],szMessage))
	{
		client_print_color(iIndex,print_team_default,"^4[%s] ^1The key ^3%s ^1isn't exist in the ^3%s ^1mode.",PREFIX,szMessage,g_szModes[iMode]);
		
		return;
	}
	
	if(!cmd_RemoveableKey(szMessage))
	{
		client_print_color(iIndex,print_team_default,"^4[%s] ^1The key ^3%s ^1cannot be reomve at ^3%s ^1mode.",PREFIX,szMessage,g_szModes[iMode]);
		
		return;
	}
	
	new iSize = ArraySize(g_aKeys[iMode]);
	
	new szKey[25];
	
	for(new i; i < iSize; i++)
	{
		ArrayGetString(g_aKeys[iMode],i,szKey,sizeof szKey);
		
		if(equali(szKey,szMessage))
			ArrayDeleteItem(g_aKeys[iMode],i);
	}
	
	TrieDeleteKey(g_tKeys[iMode],szMessage);
	
	client_print_color(iIndex,print_team_default,"^4[%s] ^1You have successfully removed the key ^3%s ^1from the ^3%s^1.",PREFIX,szMessage,g_szModes[iMode]);
	
	cmd_SaveFile(iMode);
}

public client_authorized(iIndex,const szKey[])
{
	static iMode;
	
	iMode = get_pcvar_num(g_iCvar);
	
	if(iMode == MODE_EVERYONE)
		return;
	
	switch(iMode)
	{
		case MODE_WHITELIST:
		{
			if(!TrieKeyExists(g_tKeys[iMode],szKey))
				server_cmd("kick #%i ^"%s^"", get_user_userid(iIndex),g_szMessages[LIST_WHITE]);
		}
		
		case MODE_BLACKLIST:
		{
			if(TrieKeyExists(g_tKeys[iMode],szKey))
				server_cmd("kick #%i ^"%s^"", get_user_userid(iIndex),g_szMessages[LIST_BLACK]);
		}
	}
}

public menu_ManageMain(const iIndex)
{
	if(get_user_access(iIndex) < ServerManager)
	{
		client_print_color(iIndex,print_team_default,"^4[%s] ^1You have no access to this command.",PREFIX);
		
		return PLUGIN_HANDLED;
	}
	
	static iMode;
	
	iMode = get_pcvar_num(g_iCvar);
	
	new szText[512],iLen,iKeys;
	
	iLen += formatex(szText[iLen], charsmax(szText) - iLen,"\r[ \w%s \r] \wManage Connections Main Menu^n^n",PREFIX);
	
	iLen += formatex(szText[iLen], charsmax(szText) - iLen,"\d- \wCurrent Mode: \y%s\d.^n^n",g_szModes[iMode]);
	
	iLen += formatex(szText[iLen], charsmax(szText) - iLen,"\r1. \wChange mode\d.^n");
	
	iLen += formatex(szText[iLen], charsmax(szText) - iLen,"\%c2. \wAdd new key\d.^n",iMode != MODE_EVERYONE ? 'r' : 'd');
	
	iLen += formatex(szText[iLen], charsmax(szText) - iLen,"\%c3. \wView keys list\d.^n",iMode != MODE_EVERYONE ? 'r' : 'd');
	
	if(iMode != MODE_EVERYONE)
		iKeys |= (1 << 1) | (1 << 2);
		
	iLen += formatex(szText[iLen], charsmax(szText) - iLen,"^n\r0. \wExit \yManage Connections Main Menu");
	
	iKeys |= (1 << 0) | (1 << 9);
	
	display_menu(iIndex,iKeys,szText,"handler_ManageMain");
	
	return PLUGIN_HANDLED;
}

public handler_ManageMain(const iIndex, const iKey)
{
	switch((iKey + 1) % 10)
	{
		case 0:
			return;
			
		case 1:
			menu_Modes(iIndex);
			
		case 2:
			client_cmd(iIndex,"messagemode amx_addkey");
			
		case 3:
			menu_Keys(iIndex);
	}
}

public menu_Modes(const iIndex)
{
	new szText[512],iLen,iKeys;
	
	iLen += formatex(szText[iLen], charsmax(szText) - iLen,"\r[ \w%s \r] \wManage Connections Modes Menu^n^n",PREFIX);
	
	for(new i; i < eModes; i++)
	{
		iLen += formatex(szText[iLen], charsmax(szText) - iLen,"\r%i. \w%s^n",i + 1, g_szModes[i]);
		
		iKeys |= (1 << i);
	}
	
	iLen += formatex(szText[iLen], charsmax(szText) - iLen,"^n\r0. \wBack to \yManage Connections Main Menu");
	
	iKeys |= (1 << 9);
	
	display_menu(iIndex,iKeys,szText,"handler_Modes");
}

public handler_Modes(const iIndex, const iKey)
{
	if((iKey + 1) % 10 == 0)
	{
		menu_ManageMain(iIndex);
		
		return;
	}
	
	set_pcvar_num(g_iCvar,iKey);
	
	client_print_color(iIndex,print_team_default,"^4[%s] ^1You have successfully changed the connetion mode to ^3%s^1.",PREFIX,g_szModes[iKey]);
	
	menu_ManageMain(iIndex);
}

public menu_Keys(const iIndex)
{
	static iMode;
	
	iMode = get_pcvar_num(g_iCvar);
	
	if(iMode == MODE_EVERYONE)
	{
		client_print_color(iIndex,print_team_default,"^4[%s] ^1You cannot watch key list at ^3%s ^1mode.",PREFIX,g_szModes[iMode]);
		
		menu_ManageMain(iIndex);
		
		return;
	}
	
	new szText[512],iSize,szKey[25];
	
	iSize = ArraySize(g_aKeys[iMode]);
	
	formatex(szText,charsmax(szText),"\r[ \w%s \r] \wManage Connections \y%s\w's Keys Menu",PREFIX,g_szModes[iMode]);
	new iMenu = menu_create(szText,"handler_Keys");

	for(new i; i < iSize; i++)
	{
		ArrayGetString(g_aKeys[iMode],i,szKey,sizeof szKey);
		
		menu_additem(iMenu,get_key_name(szKey),szKey);
	}	
	
	menu_setprop(iMenu,MPROP_EXITNAME,"Back to \yManage Connections Main Menu");
	
	
	if(menu_items(iMenu))
		menu_display(iIndex,iMenu);
	
	else
	{
		client_print_color(iIndex,print_team_default,"^4[%s] ^1There are no keys at ^3%s ^1mode.",PREFIX,g_szModes[iMode]);
		
		menu_ManageMain(iIndex);
	}
}

public handler_Keys(const iIndex, const iMenu, const iItem)
{
	if(iItem == MENU_EXIT)
	{
		menu_destroy(iMenu);
		
		menu_ManageMain(iIndex);
		
		return;
	}
	
	new iShit,szKey[25];
	
	menu_item_getinfo(iMenu,iItem,iShit,szKey,charsmax(szKey),_,_,iShit);
	menu_destroy(iMenu);
	
	menu_ViewKey(iIndex,szKey);
}

public menu_ViewKey(const iIndex, const szKey[])
{
	static iMode;
	
	iMode = get_pcvar_num(g_iCvar);
	
	if(iMode == MODE_EVERYONE)
	{
		client_print_color(iIndex,print_team_default,"^4[%s] ^1You cannot watch keys at ^3%s ^1mode.",PREFIX,g_szModes[iMode]);
		
		menu_ManageMain(iIndex);
		
		return;
	}
	
	if(!TrieKeyExists(g_tKeys[iMode],szKey))
	{
		client_print_color(iIndex,print_team_default,"^4[%s] ^1That key is not at ^3%s^1.",PREFIX,g_szModes[iMode]);
		
		menu_Keys(iIndex);
		
		return;
	}
	
	copy(g_szKey[iIndex],charsmax(g_szKey[]),szKey);
	
	new szText[512],iLen,iKeys;
	
	iLen += formatex(szText[iLen], charsmax(szText) - iLen,"\r[ \w%s \r] \wManage Connections View Key Menu^n\wYou are viewing \y%s\w:^n^n",PREFIX,get_key_name(szKey));
	
	iLen += formatex(szText[iLen], charsmax(szText) - iLen,"\d- \wCurrent Mode: \y%s\d.^n",g_szModes[iMode]);
	
	iLen += formatex(szText[iLen], charsmax(szText) - iLen,"\d- \wPlayer Key: \y%s\d.^n",szKey);
	
	iLen += formatex(szText[iLen], charsmax(szText) - iLen,"^n\%c1. \wDelete Key\d.^n",cmd_RemoveableKey(szKey) ? 'r' : 'd');
	
	iLen += formatex(szText[iLen], charsmax(szText) - iLen,"^n\r0. \wBack to \yManage Connections Keys Menu");
	
	if(cmd_RemoveableKey(szKey))
		iKeys |= (1 << 0);
	
	iKeys |= (1 << 9);
	
	display_menu(iIndex,iKeys,szText,"handler_ViewKey");
	
	return;
}

public handler_ViewKey(const iIndex, const iKey)
{
	if((iKey + 1) % 10 == 0)
	{
		menu_Keys(iIndex);
		
		return;
	}
	
	client_cmd(iIndex,"amx_removekey %s",g_szKey[iIndex]);
	
	menu_ManageMain(iIndex);
}

public think_Entity(const iEntity)
{
	if(iEntity == g_iEntity)
	{
		static i,szKey[25],iMode;
		
		iMode = get_pcvar_num(g_iCvar);
		
		if(iMode != MODE_EVERYONE)
		{
			switch(iMode)
			{
				case MODE_WHITELIST:
				{
					for(i = 1; i <= MaxClients; i++)
					{
						if(!is_user_connected(i))
							continue;
							
						get_user_authid(i,szKey,charsmax(szKey));
						
						if(!TrieKeyExists(g_tKeys[iMode],szKey))
							server_cmd("kick #%i ^"%s^"", get_user_userid(i),g_szMessages[LIST_WHITE]);
					}
				}
				
				case MODE_BLACKLIST:
				{
					
					for(i = 1; i <= MaxClients; i++)
					{
						if(!is_user_connected(i))
							continue;
							
						get_user_authid(i,szKey,charsmax(szKey));
						
						if(TrieKeyExists(g_tKeys[iMode],szKey))
							server_cmd("kick #%i ^"%s^"", get_user_userid(i),g_szMessages[LIST_BLACK]);
					}
				}
			}
		}
		
		cmd_SetEntityThink();
	}
}

stock cmd_ValidKey(const Key[])
{
	if(strlen(Key) < 8)
		return false;
	
	if(containi(Key,"STEAM_") != -1 || containi(Key,".") != -1 || containi(Key,"loopback") != -1)
			return true;
			
	return false;
}

stock cmd_RemoveableKey(const szKey[])
{
	static iMode;
	
	iMode = get_pcvar_num(g_iCvar);
	
	if(iMode == MODE_EVERYONE)
		return false;
	
	for(new i; i < sizeof g_aAutoKeys; i++)
	{
		if(equali(szKey,g_aAutoKeys[i][ak_szKey]) && iMode == g_aAutoKeys[i][ak_iList])
			return false;
	}

	return true;
}

stock cmd_SetEntityThink()
	entity_set_float(g_iEntity,EV_FL_nextthink,halflife_time() + AUTO_CHECK);

stock cmd_LoadFile(const iFile)
{
	new f = fopen(g_szFiles[iFile],"rt");
	
	if(!file_exists(g_szFiles[iFile]))
		return;
	
	new szBuffer[32];
	
	while(fgets(f,szBuffer,charsmax(szBuffer)))
	{
		replace(szBuffer,charsmax(szBuffer),"^n","");
		trim(szBuffer);
		
		if(szBuffer[0] == EOS)
			continue;
		
		ArrayPushString(g_aKeys[iFile],szBuffer);
		TrieSetCell(g_tKeys[iFile],szBuffer,1);
	}
	
	fclose(f);
}

stock cmd_SaveFile(const iFile)
{
	new f = fopen(g_szFiles[iFile],"wt");
	
	new szBuffer[32];
	
	new iSize = ArraySize(g_aKeys[iFile]);
	
	for(new i; i < iSize; i++)
	{
		ArrayGetString(g_aKeys[iFile],i,szBuffer,sizeof szBuffer);
		add(szBuffer,charsmax(szBuffer)," ^n");
		
		fputs(f,szBuffer);
	}
	
	fclose(f);
}

stock cmd_LoadAutoList()
{
	for(new i; i < sizeof g_aAutoKeys; i++)
	{
		if(!TrieKeyExists(g_tKeys[g_aAutoKeys[i][ak_iList]],g_aAutoKeys[i][ak_szKey]))
		{
			ArrayPushString(g_aKeys[g_aAutoKeys[i][ak_iList]],g_aAutoKeys[i][ak_szKey]);
			TrieSetCell(g_tKeys[g_aAutoKeys[i][ak_iList]],g_aAutoKeys[i][ak_szKey],1);
		}
	}
}
