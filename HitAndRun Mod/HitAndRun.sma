/* Plugin generated by AMXX-Studio */

#include "amxmodx.inc"
#include "engine.inc"
#include "hamsandwich.inc"
#include "engine.inc"
#include "cstrike.inc"
#include "fun.inc"
#include "hitandrun.inc"
#include "fakemeta.inc"

#define PLUGIN "Hit And Run System"
#define VERSION "Never-Tested"
#define AUTHOR "MJ"

#define PREFIX "HNR System"

// Fronst Grenade
#define TASK_EXPLODE(%1) ( 799 + %1 )
#define UNTASK_EXPLODE(%1) ( %1 - 799)

#define TASK_UNFREEZE(%1) ( 899 + %1 )
#define UNTASK_UNFREEZE(%1) ( %1 - 899 )

#define HUD_HIDE_FLASH (1<<1)
#define HUD_HIDE_RHA (1<<3)
#define HUD_HIDE_TIMER (1<<4)
#define HUD_HIDE_MONEY (1<<5)

#define TASK_FLARE 1204
#define TASK_BEAM 1300
#define TASK_VOTEEFFECTS 2140
#define AMOUNT_OF_FLARES 8

#define FALL_VELOCITY 350.0

#define EVENT_EACH_ROUNDS 3
#define EVENT_ITEMS 4

#pragma semicolon 1



// Fronst Grenade
enum _:FrostSounds
{
	Explode,
	Hit,
	Unfreeze
}

new const szFrostSoundsPath[ FrostSounds ][ ] = {
	"warcraft3/frostnova.wav",
	"warcraft3/impalehit.wav",
	"warcraft3/impalelaunch1.wav"
};

new bool: g_bFrozen[ 33 ], g_iBeaconSprite;

// Winnings Effect

new const g_szFlareFormat[] = "sprites/flares/";
new const g_szFlareEnd[] = "_flare.spr";

new g_iFlares[AMOUNT_OF_FLARES + 1];
new g_iBeamSprite;

// Infect Data

enum _: InfectData
{
	id_iAlives,
	id_iInfects
}

new const g_iInfects[][InfectData] =
{
	{16,3},
	{10,2},
	{MIN_PLAYERS_TO_START_GAME,1}
};

new bool:g_bInfected[MAX_PLAYERS + 1];
new g_iInfector[MAX_PLAYERS + 1];

new g_szInfectedModelname[] = "iPlay_HNR_Infected";

new g_szSoundLocation[] = "UniqueGaming/HitAndRun";

new g_szInfectedSoundFormat[] = "Infected/infect";
new g_szInfectedSoundEnd[] = "wav";

// Game Settings

enum _: Statuses
{
	STATUS_DOWN,
	STATUS_VOTEEVENT,
	STATUS_CD,
	STATUS_RUNNING,
	STATUS_PAUSE,
	STATUS_WINNING,
	STATUS_ENDED
}

new g_iEntity;
new g_szEntityClassname[] = "HitAndRun_Thinker";

new Float:g_fTimer; // Timer of INFECT
new g_iGameCD; // CD of start GAME
new g_iGameStatus; // GAME STATUS

// Events

enum _: eEvents
{
	EVENT_X,
	EVENT_X2,
	EVENT_X3,
	EVENT_X4,
	EVENT_Xtreme,
}

new const g_szEvents[eEvents][] =
{
	"Event X",
	"Event X2",
	"Event X3",
	"Event X4",
	"Event Xtreme",
};

new g_iRound;

new bool:g_bVoted[MAX_PLAYERS + 1],bool:g_bShowMenu[MAX_PLAYERS + 1],g_iEventsIDs[EVENT_ITEMS], g_iVotes[EVENT_ITEMS],g_iTotalVotes;

// Forwards

enum _: eForwards
{
	hWinner,
	hGameStarted,
	hEventStarted,
	hPreInfected,
	hInfected
}

new g_hForwards[eForwards];

// messages
new g_iMsgScreenFade,g_iMsgHideWeapon;


// anti fall damage
new g_iFalling[MAX_PLAYERS + 1];

public plugin_init() {
	register_plugin(PLUGIN, VERSION, AUTHOR);

	RegisterHam(Ham_TakeDamage,"player","fwd_TakeDamage",0);
	RegisterHam(Ham_Spawn,"player","fwd_Spawn",1);
	RegisterHam(Ham_Killed,"player","fwd_Killed",1);
	
	register_event("HLTV","event_OnNewRound", "a", "1=0", "2=0");
	
	g_iEntity = create_entity("info_target");
	entity_set_string(g_iEntity,EV_SZ_classname,g_szEntityClassname);
	
	register_think(g_szEntityClassname,"think_Entity");
	
	//register_logevent("event_RoundStart",2,"1=Round_Start");
	// register_logevent("event_RoundEnd",2,"1=Round_End");
	
	g_iMsgHideWeapon = get_user_msgid("HideWeapon");
	register_message(g_iMsgHideWeapon, "message_HideWeapon");
	register_event("ResetHUD", "event_ResetHUD", "b");
	
	g_iMsgScreenFade = get_user_msgid("ScreenFade");
	register_event("ScreenFade","event_Flashbang","be","4=255","5=255","6=255","7>199");
	
	g_hForwards[hWinner] = CreateMultiForward("fwd_PlayerWon",ET_IGNORE,FP_CELL);
	g_hForwards[hPreInfected] = CreateMultiForward("fwd_PrePlayerInfected",ET_CONTINUE,FP_CELL,FP_CELL);
	g_hForwards[hInfected] = CreateMultiForward("fwd_PlayerInfected",ET_IGNORE,FP_CELL);
	g_hForwards[hGameStarted] = CreateMultiForward("fwd_GameStarted",ET_IGNORE);
	g_hForwards[hEventStarted] = CreateMultiForward("fwd_EventStarted",ET_IGNORE);
	
	register_forward( FM_SetModel, "fwd_SetModel_Pre" );
}

public plugin_precache()
{	
	new szAdress[128],i;
	
	formatex(szAdress,charsmax(szAdress),"models/player/%s/%s.mdl",g_szInfectedModelname,g_szInfectedModelname);
	
	if(file_exists(szAdress))
		precache_model(szAdress);
		
	else
		set_fail_state("[%s] File cannot be found. (%s)",PLUGIN,szAdress);
	
	for(i = 1; i <= INFECTED_SOUND_AMOUNT; i++)
	{
		formatex(szAdress,charsmax(szAdress),"%s/%s%d.%s",g_szSoundLocation,g_szInfectedSoundFormat,i,g_szInfectedSoundEnd);
		precache_sound(szAdress);
	}
	
	for(i = 1; i <= AMOUNT_OF_FLARES; i++)
	{
		formatex(szAdress,charsmax(szAdress),"%s%d%s",g_szFlareFormat,i,g_szFlareEnd);
		
		if(file_exists(szAdress))
			g_iFlares[i] = precache_model(szAdress);
			
		else
			set_fail_state("[%s] File cannot be found. (%s)",PLUGIN,szAdress);
	}
	
	for(i = 0; i < FrostSounds; i ++)
		precache_sound(szFrostSoundsPath[i]);
		
	g_iBeaconSprite = precache_model("sprites/shockwave.spr");
	
	g_iBeamSprite = precache_model( "sprites/zbeam2.spr" );
}

public plugin_end()
	for(new i; i < eForwards; i++)
		DestroyForward(g_hForwards[i]);

// Connecting & Disconneting

public client_putinserver(iIndex)
{
	g_bInfected[iIndex] = false;
	g_bVoted[iIndex] = true;
	g_bShowMenu[iIndex] = false;
}

public client_disconnected(iIndex)
{
	g_bInfected[iIndex] = false;
	cmd_ResetInfection(iIndex);
}

// Thinker

public think_Entity(iEntity)
{
	if(g_iEntity == iEntity)
	{
		new iAlive = cmd_CountAlivePlayers();
		
		switch(g_iGameStatus)
		{
			case STATUS_DOWN:
			{
				if(iAlive < MIN_PLAYERS_TO_START_GAME)
				{
					set_dhudmessage(0, 255, 255, -1.0, 0.24, 0, 6.0, TIME_TO_RETRY_START_CD);
					show_dhudmessage(0, "There are not enough players^n Waiting for %d more player%s",MIN_PLAYERS_TO_START_GAME- iAlive,MIN_PLAYERS_TO_START_GAME- iAlive > 1 ? "s" : "");
					//client_print_color(0,print_team_default,"^4[%s] ^1The game cannot be started until ^3%d ^1alive players.",PREFIX,MIN_PLAYERS_TO_START_GAME);
					cmd_SetThinkIn(TIME_TO_RETRY_START_CD);
					return;
				}
				
				if(g_iRound == EVENT_EACH_ROUNDS && EVENT_ITEMS <= eEvents)
				{
					g_iGameStatus = STATUS_VOTEEVENT;
					
					cmd_StartVote();
				}
				
				else
					g_iGameStatus = STATUS_CD;
				
				cmd_SetThinkIn(1.0);
			}
			
			case STATUS_VOTEEVENT:
			{
				if(iAlive < MIN_PLAYERS_TO_START_GAME)
				{	
					for(new i = 1; i <= MaxClients; i++)
					{
						if(!is_user_connected(i))
							continue;
							
						if(music_SoundEnabled(i,SOUND_VOTEEVENT))
							client_cmd(i,"mp3 stop");
					}
					
					cmd_StartGame();
					cmd_SetThinkIn(1.0);
					
					return;
				}
				
				if(g_iGameCD)
				{
					menu_VoteEvent();
					g_iGameCD --;
				}
				
				else
				{
					g_iGameCD = LENGTH_OF_CD_GAME;
					g_iGameStatus = STATUS_CD;
	
					new iWinner = cmd_Winner();
					
					client_print_color(0,print_team_default,"^4[%s] ^1The event ^3%s ^1has won with ^4%d ^1vote%s.",PREFIX,g_szEvents[g_iEventsIDs[iWinner]], g_iVotes[iWinner],g_iVotes[iWinner] == 1 ? "" : "s");
					
					for(new i = 1; i <= MaxClients; i++)
					{
						if(!is_user_connected(i) || !g_bShowMenu[i])
							continue;
							
						show_menu(i,0,"^n",1);
					}
				}
				
				cmd_SetThinkIn(1.0);
			}
			
			case STATUS_CD:
			{
				if(iAlive < MIN_PLAYERS_TO_START_GAME)
				{
					cmd_StartGame();
					cmd_SetThinkIn(1.0);
					return;
				}
				
				set_dhudmessage(0, 255, 255, -1.0, 0.24, 0, 6.0, 1.0,0.0,0.05);
				show_dhudmessage(0, "The %s will be started in: %d",g_iRound == EVENT_EACH_ROUNDS ? "event" : "infection",g_iGameCD);
				
				new szVox[8];
				num_to_word(g_iGameCD,szVox,charsmax(szVox));
				
				for(new i = 1; i <= MaxClients; i++)
				{
					if(!is_user_connected(i))
						continue;
					
					if(music_SoundEnabled(i,SOUND_CD))
						client_cmd(i,"spk ^"vox/%s^"",szVox);
				}
				
				g_iGameCD --;
				
				if(g_iGameCD <= 0)
				{
					g_iGameStatus = STATUS_RUNNING;
					
					static iReturn;
					
					if(g_iRound == EVENT_EACH_ROUNDS && EVENT_ITEMS <= eEvents)
					{
						cmd_Event();
						ExecuteForward(g_hForwards[hEventStarted],iReturn);
					}
					
					else
						ExecuteForward(g_hForwards[hGameStarted],iReturn);
				}
					
				cmd_SetThinkIn(1.0);
			}
			
			case STATUS_RUNNING:
			{
				if(iAlive == 1)
					g_iGameStatus = STATUS_WINNING;
				else
				{
					if(g_fTimer == LENGTH_OF_INFECT_TIMER)
					{
						client_print_color(0,print_team_default,"^4[%s] ^1The infection will be ended in ^4%.1f ^1seconds.",PREFIX,g_fTimer);
						cmd_InfectRandom();
					}
						
					set_dhudmessage(0, 170, 255, -1.0, 0.70, 1, 0.0, 0.1,0.0,0.05);
					show_dhudmessage(0, "Infection remaining: %.1f second%s",g_fTimer, g_fTimer > 1.0 ? "s" : "");
					
					set_hudmessage(random_num(0,255), random_num(0,255), random_num(0,255), -1.0, 0.75, 1, 0.0, 0.1,0.0,0.05,1);
					show_hudmessage(0, "Infection:^n %s",cmd_GetInfectedNames());
					
					g_fTimer -= 0.1;
					
					if(g_fTimer <= 0.0)
					{
						g_fTimer = LENGTH_OF_PAUSE_TIMER;
						g_iGameStatus = STATUS_PAUSE;
						cmd_KillInfected();
					}
				}
				
				cmd_SetThinkIn(0.1);
			}
			
			case STATUS_PAUSE: 
			{
				if(iAlive == 1)
					g_iGameStatus = STATUS_WINNING;
				else
				{
					if(g_fTimer == LENGTH_OF_PAUSE_TIMER)
					{
						client_print_color(0,print_team_default,"^4[%s] ^1The next infection will be started in ^4%.1f ^1seconds.",PREFIX,g_fTimer);
					}
					
					
					set_dhudmessage(0, 170, 255, -1.0, 0.70, 0, 6.0, 0.1,0.0,0.05);
					show_dhudmessage(0, "Next infect in: %.1f second%s",g_fTimer, g_fTimer > 1.0 ? "s" : "");
				
					g_fTimer -= 0.1;
					
					if(g_fTimer <= 0.0)
					{
						g_fTimer = LENGTH_OF_INFECT_TIMER;
						g_iGameStatus = STATUS_RUNNING;
					}
				}
			
				cmd_SetThinkIn(0.1);
			}
			
			case STATUS_WINNING:
			{
				new iSurvivor = cmd_GetLastSurvivor();
				
				new iPlayers = cmd_CountPlayers();
				
				for(new i = 1; i <= MaxClients; i++)
				{
					if(!is_user_connected(i))
						continue;
					
					if(music_SoundEnabled(i,SOUND_WINNING))
						music_RandomChorus(i);
				}
				
				if(iSurvivor)
				{
					static iReturn;
					
					ExecuteForward(g_hForwards[hWinner], iReturn,iSurvivor);
					
					set_lights("d");
					
					new szName[MAX_NAME_LENGTH];
					get_user_name(iSurvivor,szName,charsmax(szName));
					
					set_hudmessage(0, 85, 255, -1.0, 0.66, 2, LENGTH_OF_WINNING_STATUS / 2.0, LENGTH_OF_WINNING_STATUS);
					
					new iExperience = stat_MultiplyExperience(iSurvivor,EXP_PER_KILL * MULTIPLY_EXP_WINNING);
					
					for(new i = 1; i <= MaxClients; i++)
					{
						if(!is_user_connected(i))
							continue;
							
						if(i == iSurvivor)
						{
							if(iPlayers >= MIN_PLAYERS_TO_GET_EXP)
								client_print_color(i,print_team_default,"^4[%s] ^1You have won the round and got ^4%i ^1experience points.",PREFIX,iExperience);
							else
								client_print_color(i,print_team_default,"^4[%s] ^1You have won the round.",PREFIX);
								
							show_dhudmessage(i, "You have won the round!");
						}
							
						else
						{
							client_print_color(i,print_team_default,"^4[%s] ^3%s ^1has won the round.",PREFIX,szName);
							
							show_dhudmessage(i, "%s has won the round!",szName);
						}	
					}
					
					if(iPlayers >= MIN_PLAYERS_TO_GET_EXP)
						exp_AddUserData(iSurvivor,EXPERIENCE_DATA_EXPERIENCE,iExperience);
						
					message_Flare(iSurvivor + TASK_FLARE);
					message_Beam(iSurvivor + TASK_BEAM);
				}
				
				g_iGameStatus = STATUS_ENDED;
				
				cmd_SetThinkIn(LENGTH_OF_WINNING_STATUS);
			}
			
			case STATUS_ENDED: 
			{
				g_iGameStatus = STATUS_DOWN;
				
				new iSurvivor = cmd_GetLastSurvivor();
				remove_task(iSurvivor + TASK_FLARE);
				
				set_cvar_num("sv_restart",1);
			}
		}
	}
}

public fnExplodeNade( Task_ID )
{
	new iEnt = UNTASK_EXPLODE( Task_ID );
	if( !pev_valid( iEnt ) )
		return;
		
	new iOwner = pev( iEnt, pev_owner ), Float: g_flOrigin[ 3 ], g_iOrigin[ 3 ], Float: g_flPlayerOrigin[ 3 ];
	
	pev( iEnt, pev_origin, g_flOrigin );
	
	g_iOrigin[ 0 ] = floatround( g_flOrigin[ 0 ] );
	g_iOrigin[ 1 ] = floatround( g_flOrigin[ 1 ] );
	g_iOrigin[ 2 ] = floatround( g_flOrigin[ 2 ] );
		
	CmdExplodeBeacon( g_iOrigin );
	
	engfunc( EngFunc_EmitSound, iEnt, CHAN_WEAPON, szFrostSoundsPath[ Explode ], 1.0, ATTN_NORM, 0, PITCH_NORM );
	
	for(new i = 1 ; i <= MaxClients; i ++ )
	{
		if( !is_user_alive( i ) || i == iOwner)
			continue;
			
		pev( i, pev_origin, g_flPlayerOrigin );
		
		if( get_distance_f( g_flPlayerOrigin, g_flOrigin ) > 240.0 )
			continue;
		
		if(task_exists(TASK_UNFREEZE( i )))
			remove_task(TASK_UNFREEZE( i ));
		
		g_bFrozen[ i ] = true;
		
		set_task( 2.5, "Fwd_Unfreeze", TASK_UNFREEZE( i ) );
			
		new Float: g_flGlowColor[ 3 ];
		g_flGlowColor[ 0 ] = 0.0;
		g_flGlowColor[ 1 ] = 80.0;
		g_flGlowColor[ 2 ] = 200.0;
		
		set_pev( i, pev_renderfx, kRenderFxGlowShell );
		set_pev( i, pev_rendercolor, g_flGlowColor );
		set_pev( i, pev_rendermode, kRenderNormal );
		set_pev( i, pev_renderamt, 80.0 );
		
		set_pev( i, pev_flags, pev( i, pev_flags ) | FL_FROZEN );
		
		engfunc( EngFunc_EmitSound, i, CHAN_WEAPON, szFrostSoundsPath[ Hit ], 1.0, ATTN_NORM, 0, PITCH_NORM);
			
		message_begin( MSG_ONE, get_user_msgid("ScreenFade"), _, i);
		write_short( ~0 );
		write_short( ~0 );
		write_short( 0x0004 );
		write_byte( 100 );
		write_byte( 200 );
		write_byte( 255 );
		write_byte( 100 );
		message_end( );
		set_pev( i, pev_flags, pev( i, pev_flags ) | FL_FROZEN );
	}
	
	engfunc( EngFunc_RemoveEntity , iEnt );
}

public Fwd_Unfreeze( Task_ID )
{
	new client = UNTASK_UNFREEZE( Task_ID );
		
	if(!g_bInfected[client])
		set_user_rendering(client);
	else
		set_user_rendering(client,kRenderFxGlowShell,random_num(100,255),random_num(100,255),random_num(100,255),kRenderTransAlpha,20);
	
	message_begin( MSG_ONE, get_user_msgid("ScreenFade"), _, client);
	write_short( 0 );
	write_short( 0 );
	write_short( 0 );
	write_byte( 0 );
	write_byte( 0 );
	write_byte( 0 );
	write_byte( 0 );
	message_end( );
	
	g_bFrozen[ client ] = false;
	
	set_pev( client, pev_flags, pev( client, pev_flags ) & ~FL_FROZEN );
	
	engfunc( EngFunc_EmitSound, client, CHAN_WEAPON, szFrostSoundsPath[ Unfreeze ], 1.0, ATTN_NORM, 0, PITCH_NORM);
}

public CmdExplodeBeacon( const g_iOrigin[3] )
{
	message_begin( MSG_BROADCAST, SVC_TEMPENTITY );
	write_byte( TE_BEAMCYLINDER );
	write_coord( g_iOrigin[0] );
	write_coord( g_iOrigin[1] );
	write_coord( g_iOrigin[2] );
	write_coord( g_iOrigin[0] );
	write_coord( g_iOrigin[1] );
	write_coord( g_iOrigin[2] + 240);
	write_short( g_iBeaconSprite );
	write_byte( 0 );
	write_byte( 0 );
	write_byte( 8 );
	write_byte( 60 );
	write_byte( 0 );
	write_byte( 40 );
	write_byte( 100 );
	write_byte( 200 );
	write_byte( 200 );
	write_byte( 3 );
	message_end();
}

public menu_VoteEvent()
{
	new szText[512],iLen,iKeys;
	
	
	for(new i = 1,j; i <= MaxClients; i++)
	{
		if(!is_user_connected(i) || !g_bShowMenu[i])
			continue;
			
		iLen = 0;
		
		iKeys = (1 << 9);
		
		iLen += formatex(szText[iLen], charsmax(szText) - iLen,"\r[ \w%s \r] \wVote Events Menu^n\dChoose your favorite option:^n^n",PREFIX);
		
		iLen += formatex(szText[iLen], charsmax(szText) - iLen,"\d- \yTime to choose: \w%i second%s\d.^n^n",g_iGameCD,g_iGameCD == 1 ? "" : "s");
	
		for(j = 0; j < sizeof g_iEventsIDs; j++)
		{
			iLen += formatex(szText[iLen], charsmax(szText) - iLen,"\%c%i. \w%s Event \d[\r%i Votes \d- \y%.2f%%\d]^n",g_bVoted[i] ? 'd' : 'r',j + 1,g_szEvents[g_iEventsIDs[j]],g_iVotes[j],float(g_iVotes[j]) / float(g_iTotalVotes) * 100.0);
			
			if(!g_bVoted[i])
				iKeys |= (1 << j);
		}
		
		iLen += formatex(szText[iLen], charsmax(szText) - iLen,"^n\%c%i. \yStop show up\d.^n",g_bVoted[i] ? 'r' : 'd',sizeof g_iEventsIDs + 1);
		
		if(g_bVoted[i])
			iKeys |= (1 << sizeof g_iEventsIDs);
		
		iLen += formatex(szText[iLen], charsmax(szText) - iLen,"^n\r0. \wExit \yVote Events Menu");
		
		display_menu(i,iKeys,szText,"handler_VoteEvent");
	}
	
}

public handler_VoteEvent(const iIndex, const iKey)
{
	switch((iKey + 1) % 10)
	{
		case 0:
			return;
			
		case 1..EVENT_ITEMS:
		{
			if(g_bVoted[iIndex])
			{
				client_print_color(iIndex,print_team_default,"^4[%s] ^1You have already voted.",PREFIX);
				
				return;
			}
				
			g_bVoted[iIndex] = true;
				
			g_iVotes[iKey] ++;
			g_iTotalVotes ++;
			
			client_print_color(iIndex,print_team_default,"^4[%s] ^1You have successfully voted for ^3%s^1.",PREFIX,g_szEvents[g_iEventsIDs[iKey]]);
		}
		
		case EVENT_ITEMS + 1:
		{
			client_print_color(iIndex,print_team_default,"^4[%s] ^1You have stopped the ^3Vote Events Menu^1's showing up.",PREFIX);
			g_bShowMenu[iIndex] = false;
		}
	}
}

public cmd_StartVoteEffects(const iTaskID)
{
	for(new i = 1; i <= MaxClients; i++)
	{
		if(!is_user_alive(i))
			continue;
			
		cmd_CreateShake(i,float(LENGTH_OF_CD_GAME));
		
		if(music_SoundEnabled(i,SOUND_VOTEEVENT))
			music_RandomChorus(i);
	}
}

// Fowards

public fwd_TakeDamage(const iVictim,const iInflictor,const iAttacker,Float:fDamage,const iDmgBits)
{
	if(!iAttacker || iAttacker > MaxClients || iAttacker == iVictim || g_iGameStatus != STATUS_RUNNING)
		return HAM_SUPERCEDE;
	
	if(g_bInfected[iAttacker])
		if(is_user_alive(iVictim) && !g_bInfected[iVictim])
			cmd_InfectPlayer(iVictim,iAttacker);
	
	return HAM_SUPERCEDE;
}

public fwd_Spawn(iIndex)
{
	if(is_user_alive(iIndex) && g_iGameStatus != STATUS_CD && g_iGameStatus != STATUS_DOWN)
	{
		client_print_color(iIndex,print_team_default,"^4[%s] ^1The game has already started.",PREFIX);
		cmd_BlindPlayer(iIndex,0,0,0);
		user_silentkill(iIndex);
	}
	else if(is_user_alive(iIndex))
	{
		cs_reset_user_model(iIndex);
		set_user_rendering(iIndex);
	}
}

public fwd_Killed(iKilled, iKiller)
{
	if(is_user_connected(iKilled))
	{
		cs_reset_user_model(iKilled);
		set_user_rendering(iKilled);
	}
}


public fwd_SetModel_Pre( iEnt, const Model[] )
{
	new iOwner = pev( iEnt, pev_owner );
	if( !pev_valid( iEnt ) || !equal( Model, "models/w_smokegrenade.mdl" ) || !is_user_connected( iOwner ) )
		return;
		
		
	set_pev( iEnt, pev_nextthink, get_gametime( ) + 50000000.0 );
	set_task( 1.5, "fnExplodeNade", TASK_EXPLODE( iEnt ) );
}

// Events

public event_OnNewRound()
{
	g_iRound ++;
	
	if(g_iRound > EVENT_EACH_ROUNDS)
		g_iRound = 1;
		
	else if(g_iRound == EVENT_EACH_ROUNDS)
		cmd_RandomEvents();
	
	cmd_StartGame();
}

public event_ResetHUD(id)
{	
	message_begin(MSG_ONE, g_iMsgHideWeapon, _, id);
	write_byte(HUD_HIDE_FLASH | HUD_HIDE_MONEY | HUD_HIDE_TIMER | HUD_HIDE_RHA);
	message_end();
}

public event_Flashbang(const iIndex)
{
	message_begin(MSG_ONE_UNRELIABLE, g_iMsgScreenFade,{0,0,0}, iIndex);
	write_short(read_data( 1 ));
	write_short(read_data( 2 ));
	write_short(read_data( 3 ));
	write_byte(random_num(0,255));
	write_byte(random_num(0,255));
	write_byte(random_num(0,255));
	write_byte(read_data( 7 ));
	message_end();
}

// messages

public message_HideWeapon()
{
	set_msg_arg_int(1, ARG_BYTE, get_msg_arg_int(1) | HUD_HIDE_FLASH | HUD_HIDE_MONEY | HUD_HIDE_TIMER | HUD_HIDE_RHA);
}


public message_Flare(iTaskID) 
{
	new iIndex = iTaskID - TASK_FLARE;
	
	new iOrigin[3];
	get_user_origin(iIndex, iOrigin, 0);
	
	for(new i = 0; i < 5; i++)
	{
		message_begin( MSG_BROADCAST, SVC_TEMPENTITY, iOrigin );
		write_byte ( TE_SPRITETRAIL );
		write_coord( iOrigin[0] );
		write_coord( iOrigin[1] );
		write_coord( iOrigin[2] - 70 );
		write_coord( iOrigin[0] );
		write_coord( iOrigin[1] );
		write_coord( iOrigin[2] + 50 );
		write_short( random_num(1,2) == 1 ? g_iFlares[random_num(1,AMOUNT_OF_FLARES -1)] : g_iFlares[AMOUNT_OF_FLARES] );
		write_byte ( 5 );
		write_byte ( 10 );
		write_byte ( 5 );
		write_byte ( 50 );
		write_byte ( 40 );
		message_end();
	}
	
	new iAlive = cmd_CountAlivePlayers();
	if(iAlive == 1 && (g_iGameStatus == STATUS_WINNING || g_iGameStatus == STATUS_ENDED))
		set_task(0.5, "message_Flare", TASK_FLARE + iIndex);
}

 public message_Beam(iTaskID)
{
	new iIndex = iTaskID - TASK_BEAM;
	
	new Origin[ 3 ];
	get_user_origin( iIndex, Origin );
	message_begin( MSG_BROADCAST, SVC_TEMPENTITY );
	write_byte( TE_BEAMCYLINDER );
	write_coord( Origin[ 0 ] );// start position
	write_coord( Origin[ 1 ] );
	write_coord( Origin[ 2 ] );
	write_coord( Origin[ 0 ] );// end position
	write_coord( Origin[ 1 ] );
	write_coord( Origin[ 2 ] + 200 );
	write_short( g_iBeamSprite );// sprite index
	write_byte( 0 );// starting frame
	write_byte( 50 ); // frame rate in 0.1's
	write_byte( 10 );// life in 0.1's
	write_byte( 15 );// line width in 0.1's
	write_byte( 60 );// noise amplitude in 0.01's
	write_byte( random_num(0,255) );// Red
	write_byte( random_num(0,255) );// Green
	write_byte( random_num(0,255) );// Blue
	write_byte( 255 );// brightness
	write_byte( 0 );// scroll speed in 0.1's
	message_end( );
	
	new iAlive = cmd_CountAlivePlayers();
	if(iAlive == 1 && (g_iGameStatus == STATUS_WINNING || g_iGameStatus == STATUS_ENDED))
		set_task(0.2, "message_Beam", TASK_BEAM + iIndex);
}



// Player think

public client_PreThink(iIndex) 
{
	if(is_user_alive(iIndex))
	{
		entity_set_float(iIndex,EV_FL_fuser2,0.0);
		g_iFalling[iIndex] = entity_get_float(iIndex, EV_FL_flFallVelocity) >= FALL_VELOCITY;
	}
}

public client_PostThink(iIndex) 
{
	if(is_user_alive(iIndex) && g_iFalling[iIndex])
	{
		entity_set_int(iIndex, EV_INT_watertype, -3);
	}
}

// Stocks

stock cmd_StartGame()
{
	set_lights("#OFF");
	
	g_iGameStatus = STATUS_DOWN;
	g_iGameCD = LENGTH_OF_CD_GAME;
	g_fTimer = LENGTH_OF_INFECT_TIMER;
	
	cmd_SetThinkIn(TIME_TO_START_CD);
}

stock cmd_InfectRandom()
{
	arrayset(g_bInfected,false,sizeof g_bInfected);
	
	new iAlive = cmd_CountAlivePlayers();
	
	if(iAlive >= MIN_PLAYERS_TO_START_GAME)
	{
		static i,iInfects;
		
		for(i = 0; i < sizeof g_iInfects; i++)
		{
			if(iAlive >= g_iInfects[i][id_iAlives])
			{
				iInfects = g_iInfects[i][id_iInfects];
				break;
			}
		}
				
		static iNum, players[MAX_PLAYERS];
		get_players(players,iNum,"ach");
		
		new iRandom;
		
		for(i = 0; i < iInfects; i++)
		{
			do 
				iRandom = random(iNum);
				
			while(g_bInfected[players[iRandom]]);
			
			cmd_InfectPlayer(players[iRandom],0);
		}
	}
}

stock cmd_InfectPlayer(const iInfected, const iInfector)
{
	static iReturn;
	ExecuteForward(g_hForwards[hPreInfected],iReturn,iInfected,iInfector);
	
	if(iReturn >= PLUGIN_HANDLED)
		return;
	
	static i;
	
	g_bInfected[iInfected] = true;
	g_iInfector[iInfected] = 0;
	
	cmd_CreateShake(iInfected,INFECTED_SHAKE_LENGTH);
	cs_set_user_model(iInfected,g_szInfectedModelname);
	set_user_rendering(iInfected,kRenderFxGlowShell,random_num(100,255),random_num(100,255),random_num(100,255),kRenderTransAlpha,20);
	
	if(music_SoundEnabled(iInfected,SOUND_INFECTED))
		client_cmd(iInfected,"spk ^"%s/%s%d.%s^"",g_szSoundLocation,g_szInfectedSoundFormat,random_num(1,INFECTED_SOUND_AMOUNT),g_szInfectedSoundEnd);
	
	static szInfected[MAX_NAME_LENGTH];
	get_user_name(iInfected,szInfected,charsmax(szInfected));
	
	if(iInfector)
	{	
		static szInfector[MAX_NAME_LENGTH];
		get_user_name(iInfector,szInfector,charsmax(szInfector));
		
		for(i = 1; i <= MaxClients; i++)
		{
			if(!is_user_connected(i))
				continue;
				
			if(i == iInfected)
				client_print_color(i,print_team_default,"^4[%s] ^1You have been infected by ^3%s ^1[^4%.1f^1]",PREFIX,szInfector,g_fTimer);
				
			else if(i == iInfector)
				client_print_color(i,print_team_default,"^4[%s] ^3%s ^1has been infected by you ^1[^4%.1f^1]",PREFIX,szInfected,g_fTimer);
				
			else
				client_print_color(i,print_team_default,"^4[%s] ^3%s ^1has been infected by ^3%s ^1[^4%.1f^1]",PREFIX,szInfected,szInfector,g_fTimer);
		}
		
		g_iInfector[iInfected] = iInfector;
		
		g_bInfected[iInfector] = false;
		
		cs_reset_user_model(iInfector);
		set_user_rendering(iInfector);
	}
	
	else
		for(i = 1; i <= MaxClients; i++)
		{
			if(!is_user_connected(i))
				continue;
				
			if(i == iInfected)
				client_print_color(i,print_team_default,"^4[%s] ^1You have been ^3randomly ^1infected.",PREFIX);
				
			else
				client_print_color(i,print_team_default,"^4[%s] ^3%s ^1has been ^3randomly ^1infected.",PREFIX,szInfected);
		}	
		
	ExecuteForward(g_hForwards[hInfected], iReturn,iInfected);
}

stock cmd_GetInfectedNames()
{
	new szNames[90],szName[MAX_NAME_LENGTH], iLen;
	
	for(new i = 1; i < MaxClients; i++)
		if(is_user_alive(i) && g_bInfected[i])
		{
			get_user_name(i,szName,charsmax(szName));
			iLen += formatex(szNames[iLen],charsmax(szNames) - iLen, "%s%s has been %s",iLen ? "^n" : "", szName, g_iInfector[i] ? "infected" : "randomly chosen");
		}
	
	return szNames;
}

stock cmd_KillInfected()
{
	for(new i = 1; i <= MaxClients; i++)
	{
		if(g_bInfected[i] && is_user_alive(i))
		{
			if(g_iInfector[i])
				ExecuteHamB(Ham_Killed, i, g_iInfector[i], 0);
			else
				ExecuteHamB(Ham_Killed, i, i, 0);
			
			new szInfector[MAX_NAME_LENGTH];
			new szInfected[MAX_NAME_LENGTH];
			
			get_user_name(i,szInfected,charsmax(szInfected));
			
			if(!g_iInfector[i])
					formatex(szInfector,charsmax(szInfector),"randomly chosen");
				else if(g_iInfector[i] && !is_user_connected(g_iInfector[i]))
					formatex(szInfector,charsmax(szInfector),"unknown player");
				else
					get_user_name(g_iInfector[i],szInfector,charsmax(szInfector));
			
			for(new j = 1; j <= MaxClients; j++)
			{	
				if(!is_user_connected(j))
					continue;
				
				if(j == i)
					client_print_color(j,print_team_default,"^4[%s] ^1You have been infected to death by ^3%s^1.",PREFIX,szInfector);
					
				else if(j == g_iInfector[i])
					client_print_color(j,print_team_default,"^4[%s] ^3%s ^1has been infected to death by you.",PREFIX,szInfected);
					
				else
					client_print_color(j,print_team_default,"^4[%s] ^3%s ^1has been infected to death by ^3%s^1.",PREFIX,szInfected,szInfector);
			}
		}
	}
}

stock cmd_ResetInfection(iIndex)
{
	if(g_iGameStatus != STATUS_RUNNING)
		return;
	
	for(new i = 1; i <= MaxClients;i ++)
		if(is_user_connected(i) && g_bInfected[i])
			return;
	
	new iAlive = cmd_CountAlivePlayers();
	
	if(iAlive > 1)
	{
		g_iGameStatus = STATUS_PAUSE;
		g_fTimer = LENGTH_OF_PAUSE_TIMER;
		
		new szName[MAX_NAME_LENGTH];
		get_user_name(iIndex,szName,charsmax(szName));
		
		client_print_color(0,print_team_default,"^4[%s] ^1Due to ^3%s^1's disconnection, the infection will be started again in ^4%.1f ^1seconds.",PREFIX,szName,g_fTimer);
	}
}

stock cmd_SetThinkIn(const Float:f_Seconds)
	entity_set_float(g_iEntity,EV_FL_nextthink,halflife_time() + f_Seconds);

stock cmd_GetLastSurvivor()
{
	static iAlive,players[MAX_PLAYERS];
	get_players(players,iAlive,"ach");
	
	return iAlive == 1 ? players[0] : 0;
}

stock cmd_CountAlivePlayers()
{
	static iAlive,players[MAX_PLAYERS];
	get_players(players,iAlive,"ach");
	
	return iAlive;
}

stock cmd_CountPlayers()
{
	static iAlive,players[MAX_PLAYERS];
	get_players(players,iAlive,"ch");
	
	return iAlive;
}
	
stock cmd_BlindPlayer(const iIndex,const iRed,const iGreen,const iBlue)
{
	message_begin(MSG_ONE,g_iMsgScreenFade,.player = iIndex);
	write_short(1<<15);
	write_short(1<<10);
	write_short(1<<12);
	write_byte(iRed); // Red
	write_byte(iGreen); // Green
	write_byte(iBlue); // Blue
	write_byte(255); // Alpha
	message_end();
}


stock cmd_CreateShake(const iIndex,const Float:fLength)
{
	static duration;
	
	duration = FixedUnsigned16( fLength, 1<<12 );
	
	message_begin( MSG_ONE, get_user_msgid( "ScreenShake" ), {0,0,0},  iIndex );
	write_short( 0xFFFF );
	write_short( duration );
	write_short( 0xFFFF );
	message_end();
}

stock FixedUnsigned16( Float:flValue, iScale ) 
{ 
	new iOutput;
	
	iOutput	= floatround( flValue * iScale );
	
	if ( iOutput < 0 )
		iOutput	= 0;
	
	if ( iOutput > 0xFFFF )
		iOutput	= 0xFFFF;
	
	return iOutput;
}

stock cmd_Event()
{
	new iWinner = cmd_Winner();
	
	for(new i = 1; i <= MaxClients; i++)
	{
		if(!is_user_alive(i) || cs_get_user_team(i) != CS_TEAM_T)
			continue;
			
		if(music_SoundEnabled(i,SOUND_VOTEEVENT))
			client_cmd(i,"mp3 stop");
			
		if(music_SoundEnabled(i,SOUND_AUTOMUSIC))
			music_RandomSong(i);
		
		switch(iWinner)
		{
			case EVENT_X:
			{
				give_item(i,"weapon_deagle");
			}
			
			case EVENT_X2:
			{
				give_item(i,"weapon_m4a1");
			}
			
			case EVENT_X3:
			{
				give_item(i,"weapon_ak47");
			}
			
			case EVENT_X4:
			{
				give_item(i,"weapon_mp5navy");
			}
			
			case EVENT_Xtreme:
			{
				give_item(i,"weapon_m249");
			}
		}
	}
}

stock cmd_Winner()
{
	new iWinner;
	
	for(new i; i < sizeof g_iEventsIDs; i++)
		if(g_iVotes[i] > g_iVotes[iWinner])
			iWinner = i;
	
	return iWinner;
}

stock cmd_RandomEvents()
{
	if(EVENT_ITEMS > eEventDays)
	{
		client_print_color(0,print_team_default,"^4[%s] ^1The vote event cannot be run due to there are more menu items than events.",PREFIX);
		
		return;
	}
	
	new i;
	
	do
	{
		for(i = 0; i < sizeof g_iEventsIDs; i++)
			g_iEventsIDs[i] = random(eEvents);
	}
	
	while(!cmd_EventsDifferent());
}

stock cmd_EventsDifferent()
{
	for(new i,j; i < sizeof g_iEventsIDs; i++)
		for(j = i + 1; j < sizeof g_iEventsIDs; j++)
			if(g_iEventsIDs[i] == g_iEventsIDs[j])
				return false;
	
	return true;
}

stock cmd_StartVote()
{
	arrayset(g_iVotes,0,sizeof g_iVotes);
	arrayset(g_bVoted,false,sizeof g_bVoted);
	arrayset(g_bShowMenu,true,sizeof g_bShowMenu);
	
	g_iTotalVotes = 0;
	
	set_task(1.0,"cmd_StartVoteEffects",TASK_VOTEEFFECTS);
}
