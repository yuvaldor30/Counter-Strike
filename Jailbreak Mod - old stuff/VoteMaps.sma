/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>

#define TimeToNEWMAP 45 // Minutes
#define TimeToExtendMAP 15 // Minutes
#define Max_Maps 4
#define VOTE_TASK 106
#define MaxPlayers get_maxplayers()
#define VoteMaps_Task 24912

#define TAG "UniqueGaming"
#define Chat_TAG "uG`"
#define s_IP "192.168.1.30:27015"

#define Year_Expired 2016
#define Month_Expired 9

new rMaps[Max_Maps],TimeLeft,bool:ChoosedMap,MapChoosed[30],bool:VoteTime,bool:v_Run,bool:Voted[33],CountVote,TotalVotes,Votes[Max_Maps+1];

new Array:a_Maps;

new FileLoc[128];

native get_votect_run()
native get_run_vote()
native is_run_lotto()

public plugin_init() {
	TimeLeft = TimeToNEWMAP*60;
	register_plugin("VoteMap","1.0","MJ")
	new Year[6],Month[3],year,month,serverIP[20];
	format_time(Year,charsmax(Year),"%Y",get_systime())
	format_time(Month,charsmax(Month),"%m",get_systime())
	year = str_to_num(Year);
	month = str_to_num(Month);
	get_user_ip(0,serverIP,charsmax(serverIP),0);
	if((year > Year_Expired || (year == Year_Expired && month >= Month_Expired)) || (!equali(s_IP,serverIP)))
		set_fail_state("Mod Time has been expired or Your Server IP is not allowed");
		
	set_task(1.0,"TimeToVote");
	register_clcmd("say /votemaps","VoteMaps_Start");
	register_clcmd("say /timeleft","ShowTime");
	register_clcmd("say /nextmap","ShowTime");
	get_configsdir(FileLoc,charsmax(FileLoc));
	format(FileLoc,charsmax(FileLoc),"%s/MapsList.txt",FileLoc);
	a_Maps = ArrayCreate(30);
	LoadaFile();
	register_logevent("RoundStart", 2, "1=Round_Start");
}

public plugin_natives()
	register_native("get_votemaps_run","_get_votemaps_run");

public _get_votemaps_run(plugin,param)
	return v_Run;

public LoadaFile()
{
	if(!file_exists(FileLoc))
		write_file(FileLoc," ");
	new f = fopen(FileLoc,"rt");
	
	new Data[30];
	new counter;
	while(fgets(f,Data,charsmax(Data)))
	{
		if((Data[0] == ';') || (Data[0] == '/' && Data[1] == '/') || Data[0] == ' ')
			continue;
		replace_all(Data,charsmax(Data),"^n","");
		new Loc[128];
		formatex(Loc,charsmax(Loc),"maps/%s.bsp",Data);
		if(!file_exists(Loc))
		{
			log_amx("%s doesn't exist",Loc);
			continue;
		}
		log_amx("%s has been loaded",Loc);
		ArrayPushString(a_Maps,Data);
		counter++;
	}	
	fclose(f)
	log_amx("%d Maps have been loaded",counter);
	return 1;
}

public RoundStart()
{
	if(ChoosedMap)
		server_cmd("amx_map %s",MapChoosed);
	else if(VoteTime && !v_Run && !is_run_lotto())
	{
		remove_task(VoteMaps_Task);
		Load_VoteMaps()
	}
	else
		ShowTime(0);
}

public TimeToVote()
{
	if(ArraySize(a_Maps) < 5)
	{
		log_amx("Doesn't load enough maps");
		return;
	}
	if(TimeLeft > 0)
		TimeLeft --;
	else
	{
		VoteTime = true;
		ColorChat(0,"^3Vote Maps ^1will be started ^4next round^1.");
		return;
	}
	set_task(1.0,"TimeToVote");
}

public ShowTime(id)
{
	if(ArraySize(a_Maps) < 5)
		ColorChat(id,"^1This mod is currently disabled");
	
	else if( TimeLeft > 0 && !v_Run && !VoteTime && !ChoosedMap)
	{
		new Time[2];
		new RightTime = TimeLeft;
		while(RightTime > 60)
		{
			Time[0] ++;
			RightTime -= 60;
		}
		Time[1] = RightTime;
		ColorChat(id,"^3Vote Maps ^1will be started in ^4%d ^1Minutes & ^4%d ^1 Seconds",Time[0],Time[1]);
	}
	else if(ChoosedMap)
		ColorChat(id,"^3%s ^1has been chosen, the map will be changed ^4next round^1.",MapChoosed);
	else if (v_Run)
		ColorChat(id,"^3Vote Maps ^1is running right now.");
	else if (VoteTime)
		ColorChat(id,"^3Vote Maps ^1will be started ^4next round^1.");
	return 1;
}


public VoteMaps_Start(id)
{
	if(!(get_user_flags(id) & ADMIN_CVAR))
		return ColorChat(id,"You have ^4no access ^1to this command.");
	if(ArraySize(a_Maps) < 5)
	{
		ColorChat(id,"The server doesn't load enough maps to vote maps");
		return 1;
	}
	if(!v_Run)
	{
		VoteTime = true;
		ColorChat(0,"^3Vote Maps ^1will be started ^4next round^1.");
	}
	else
		ColorChat(id,"^3Vote Maps ^1is already running." );
	return 1;
}

public RandomMaps()
{
	new ThisMap[30],Text[Max_Maps][30];
	get_mapname(ThisMap,charsmax(ThisMap));
	do
	{
		for(new i; i < Max_Maps; i++)
		{
			rMaps[i] = random_num(0,ArraySize(a_Maps)-1);
			ArrayGetString(a_Maps,rMaps[i],Text[i],29);
		}
	}
	while (equali(Text[0],Text[1]) || equali(Text[0],Text[2]) || equali(Text[0],Text[3]) || equali(Text[0],ThisMap) || equali(Text[1],Text[2]) || equali(Text[1],Text[3]) || equali(Text[1],ThisMap) || equali(Text[2],Text[3]) || equali(Text[2],ThisMap) || equali(Text[3],ThisMap))
}

public Load_VoteMaps()
{
	if(get_run_vote() || get_votect_run())
	{
		ColorChat(0,"^3Vote Maps ^1will be started in^4 25 seconds^1, another vote running now.");
		set_task(25.0,"Load_VoteMaps",VoteMaps_Task);
		return;
	}
	if(v_Run)
	{
		ColorChat(0,"^3Vote Maps ^1is already running." );
		return;
	}
	CountVote=15;
	TotalVotes = 0;
	v_Run = true;
	
	arrayset( Votes, 0, sizeof Votes );
	arrayset( Voted, 0, sizeof Voted );
	
	RandomMaps()
	VoteMaps()
}

public VoteMaps()
{
	new Text[128],MapName[30],ThisMap[30];
	get_mapname(ThisMap,charsmax(ThisMap));
	if (CountVote >= 0 && v_Run)
	{
		for (new i = 1; i <= MaxPlayers; i++) 
		{
			if(!is_user_connected(i)) continue;
			formatex(Text,127,"\r[ \w%s \r] \wChoose your favorite \yMap\w:^n\y- \dStatus: \r%s\w.^n\y- \dTime Left: \r%i\w.",TAG,Voted[i] ? "Already Voted":"Hasn't Voted",CountVote)
			new vMenu = menu_create(Text,"VoteMaps_Handler");
			for (new j; j < Max_Maps; j++) 
			{
				new Float:Ahuz = 100.0/TotalVotes*Votes[j];
				ArrayGetString(a_Maps,rMaps[j],MapName,29);
				formatex(Text,127,"\w%s \r- \d[\r%d \yVotes \w- \r%.2f\w%%\d]",MapName,Votes[j],Ahuz);
				if(j == Max_Maps-1)
					formatex(Text,127,"\w%s \r- \d[\r%d \yVotes \w- \r%.2f\w%%\d]^n",MapName,Votes[j],Ahuz);
				menu_additem(vMenu,Text);
			}
			new Float:Ahuz = 100.0/TotalVotes*Votes[Max_Maps];
			formatex(Text,127,"\dExtend Map 15 Minutes \w%s \r- \d[\r%d \yVotes \w- \r%.2f\w%%\d]",ThisMap,Votes[Max_Maps],Ahuz);
			menu_additem(vMenu,Text);
			menu_display(i,vMenu);
		}
		CountVote --;
		set_task(1.0,"VoteMaps",VOTE_TASK);
	}
	if (CountVote < 0)
	{
		show_menu(0, 0, "^n", 1);
		
		remove_task(VOTE_TASK);
	
		MapChoosed = iWinner();
		
		if(equali(MapChoosed,ThisMap))
		{
			ColorChat(0,"^3%s ^1has been chosen, the map will be extended for^4 %s ^1minutes.",MapChoosed,TimeToExtendMAP);
			
			TimeLeft = 60*TimeToExtendMAP;
			
			ChoosedMap = false;
			VoteTime = false;
			v_Run = false;
			
			set_task(1.0,"TimeToVote");
		}
		else
		{
			ColorChat(0,"^3%s ^1has been chosen, the map will be changed ^4next round^1.",MapChoosed);
			
			ChoosedMap = true;
			v_Run = false;
		}
	}
}

public VoteMaps_Handler (id,vMenu,Item)
{
	if(Item==MENU_EXIT)
	{
		menu_destroy(vMenu);
		return;
	}
	else
	{
		new MapName[30],ThisMap[30];
		get_mapname(ThisMap,charsmax(ThisMap));
		
		if(Voted[id])
		{
			ColorChat(id,"You ^1have ^3already ^1voted");
			return;
		}
		
		Voted[id] = true;
		
		Votes[Item] ++;
		TotalVotes ++;
		
		if(Item == Max_Maps)
			ColorChat(id,"You ^1have voted for ^3%s!",ThisMap);
		else
		{
			ArrayGetString(a_Maps,rMaps[Item],MapName,29);
			ColorChat(id,"You ^1have voted for ^3%s!",MapName);
		}
	}
	menu_destroy(vMenu);
}

public iWinner()
{
	new Winner,szMap[30];
	
	for( new i=0; i <= Max_Maps; i++ )
		if(Votes[i]>Votes[Winner])
			Winner = i;
			
	if(Winner == Max_Maps)
		get_mapname(szMap,charsmax(szMap));
	else
		ArrayGetArray(a_Maps,rMaps[Winner],szMap);
		
	return szMap;
}

stock ColorChat( const iPlayer, const szMsg[ ], { Float, Sql, Resul, _ } : ... )        
{
	new iMsg[ 191 ], iPlayers[ 32 ], iCount = 1;
	static iLen;
	iLen = formatex( iMsg, charsmax( iMsg ), "^4[^1 %s ^4] ^1",Chat_TAG );
	vformat( iMsg[ iLen ], charsmax( iMsg ) - iLen, szMsg, 3 );
	if ( iPlayer )
		iPlayers[ 0 ] = iPlayer;
	else    
		get_players( iPlayers, iCount, "ch" );  
	for ( new i = 0; i < iCount; i++ )
	{
		if ( ! is_user_connected( iPlayers[ i ] ) )
			continue;
		message_begin( MSG_ONE_UNRELIABLE, get_user_msgid( "SayText" ), _,iPlayers[ i ] );
		write_byte( iPlayers[ i ] );
		write_string( iMsg );
		message_end( );
	}
	return 1;
}
/* AMXX-Studio Notes - DO NOT MODIFY BELOW HERE
*{\\ rtf1\\ fbidis\\ ansi\\ ansicpg1252\\ deff0{\\ fonttbl{\\ f0\\ fnil\\ fcharset0 Tahoma;}}\n\\ viewkind4\\ uc1\\ pard\\ ltrpar\\ lang1037\\ f0\\ fs16 \n\\ par }
*/
